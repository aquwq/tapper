<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Pixel Rogue ‚Äî 32x32 Tiles Fix</title>
<style>
  :root{
    --bg:#05121a; --panel:#0b1220; --accent:#ffd166; --muted:rgba(255,255,255,0.06);
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,monospace;color:#e6eef8}
  canvas{display:block; image-rendering:pixelated}
  #game{width:100%;height:100vh}
  #ui{position:fixed;left:50%;top:8px;transform:translateX(-50%);background:rgba(2,6,23,0.66);padding:8px 12px;border-radius:12px;display:flex;gap:12px;align-items:center;z-index:60;box-shadow:0 8px 22px rgba(0,0,0,.5)}
  .stat{display:flex;gap:6px;align-items:center;font-size:13px}
  .value{font-weight:700;color:#fff}
  #panels{position:fixed;right:12px;top:74px;display:flex;flex-direction:column;gap:10px;z-index:50}
  .panel{background:var(--panel);padding:10px;border-radius:10px;min-width:220px}
  #minimap{position:fixed;right:12px;bottom:12px;border-radius:10px;border:1px solid var(--muted);z-index:55;background:#071018}
  button{background:#1f2937;border:1px solid rgba(255,255,255,0.04);color:#e6eef8;padding:8px 10px;border-radius:8px;cursor:pointer}
  .modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:var(--panel);padding:16px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);z-index:80;display:none}
  .shop-row{display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px dashed rgba(255,255,255,0.02)}
  #levelBanner{position:fixed;left:50%;top:22px;transform:translateX(-50%);background:linear-gradient(90deg,#ffd166,#ffb86b);color:#081018;padding:8px 14px;border-radius:10px;font-weight:800;display:none;z-index:70}
  @media(max-width:720px){ #ui{font-size:12px} .panel{min-width:160px} #minimap{width:140px;height:140px} }
</style>
</head>
<body>

<canvas id="game"></canvas>
<canvas id="minimap" width="180" height="180"></canvas>

<div id="ui">
  <div class="stat">‚ù§Ô∏è <span id="hp" class="value">0</span></div>
  <div class="stat">‚öî <span id="atk" class="value">0</span></div>
  <div class="stat">‚≠ê <span id="lvl" class="value">0</span></div>
  <div class="stat">XP <span id="xp" class="value">0</span></div>
  <div class="stat">üí∞ <span id="gold" class="value">0</span></div>
  <div class="stat">üåç <span id="biome" class="value">‚Äî</span></div>
  <div class="stat">‚è± <span id="time" class="value">0</span></div>
  <button id="btnShop">–ú–∞–≥–∞–∑–∏–Ω</button>
  <button id="btnInv">–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</button>
  <button id="btnReset">New Run</button>
</div>

<div id="panels">
  <div class="panel" id="wavePanel">Wave: 1</div>
  <div class="panel" id="hint">WASD / —Å—Ç—Ä–µ–ª–∫–∏ ‚Äî –¥–≤–∏–∂–µ–Ω–∏–µ. –ü–µ—Ä—Å–æ–Ω–∞–∂ —Å–º–æ—Ç—Ä–∏—Ç –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ.</div>
</div>

<div id="levelBanner">LEVEL UP!</div>

<div id="shopModal" class="modal">
  <h3>–ú–∞–≥–∞–∑–∏–Ω</h3>
  <div class="shop-row"><div>‚öî –£—Ä–æ–Ω +1</div><div><button data-buy="atk">20 G</button></div></div>
  <div class="shop-row"><div>‚ù§ –ú–∞–∫—ÅHP +12</div><div><button data-buy="hp">30 G</button></div></div>
  <div class="shop-row"><div>üß™ –•–∏–ª–∫–∞ +1</div><div><button data-buy="potion">15 G</button></div></div>
  <div style="text-align:right;margin-top:8px"><button id="shopClose">–ó–∞–∫—Ä—ã—Ç—å</button></div>
</div>

<div id="invModal" class="modal">
  <h3>–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</h3>
  <div>Potions: <span id="invPotions">0</span></div>
  <div style="margin-top:8px"><button id="usePotion">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ö–∏–ª–∫—É</button></div>
</div>

<div id="gameoverModal" class="modal">
  <h2>–¢—ã –ø–æ–≥–∏–±</h2>
  <div id="gameoverStats"></div>
  <div style="text-align:right;margin-top:8px"><button id="goRestart">Restart</button></div>
</div>

<script>
/* ====== CONFIG ====== */
const CONFIG = {
  TILE: 32,                 // <- –≥–ª–∞–≤–Ω—ã–π —Ñ–∏–∫—Å: 32x32 pixel tiles
  DPR: Math.max(1, Math.floor(window.devicePixelRatio || 1)),
  CHUNK: 512,
  PRELOAD_RADIUS: 3,
  WAVE_INTERVAL: 20000,
  INITIAL_MONSTERS: 5,
  MAX_MONSTERS: 120,
  MAX_COINS: 300,
  MAX_PARTICLES: 600,
  CHUNK_FADE_MS: 520,
  SAVE_KEY: 'pixel_32x32_v1'
};
/* ==================== */

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const minimap = document.getElementById('minimap');
const mctx = minimap.getContext('2d');

function resize(){
  const w = Math.max(900, window.innerWidth);
  const h = Math.max(600, window.innerHeight);
  canvas.width = Math.round(w * CONFIG.DPR);
  canvas.height = Math.round(h * CONFIG.DPR);
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  ctx.setTransform(CONFIG.DPR,0,0,CONFIG.DPR,0,0);
  minimap.width = parseInt(getComputedStyle(minimap).width) * CONFIG.DPR;
  minimap.height = parseInt(getComputedStyle(minimap).height) * CONFIG.DPR;
  mctx.setTransform(CONFIG.DPR,0,0,CONFIG.DPR,0,0);
}
window.addEventListener('resize', resize);
resize();

/* UI refs */
const UI = {
  hp: document.getElementById('hp'),
  atk: document.getElementById('atk'),
  lvl: document.getElementById('lvl'),
  xp: document.getElementById('xp'),
  gold: document.getElementById('gold'),
  biome: document.getElementById('biome'),
  time: document.getElementById('time'),
  wavePanel: document.getElementById('wavePanel'),
  levelBanner: document.getElementById('levelBanner'),
  shopModal: document.getElementById('shopModal'),
  invModal: document.getElementById('invModal'),
  gameover: document.getElementById('gameoverModal')
};

/* State */
let state = {
  player: { x:0, y:0, vx:0, vy:0, facing:1, hp:160, maxHp:160, atk:10, atkCd:0, atkRange:48, speed:3.0, invul:0, lvl:1, exp:0, gold:0 },
  inventory: { potions: 2 },
  monsters: [],
  coins: [],
  particles: [],
  chunks: new Map(),
  wave: 1,
  lastWaveAt: performance.now(),
  running: true,
  difficulty: 1.0,
  startedAt: performance.now()
};

/* helpers */
const rand = (a,b)=> Math.random()*(b-a)+a;
const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
const now = ()=> performance.now();

/* noise/biomes */
function hash(x,y){ return Math.abs(Math.sin(x*127.1 + y*311.7) * 43758.5453) % 1; }
function smoothNoise(x,y){
  const xi=Math.floor(x), yi=Math.floor(y);
  const xf=x-xi, yf=y-yi;
  const v00=hash(xi,yi), v10=hash(xi+1,yi), v01=hash(xi,yi+1), v11=hash(xi+1,yi+1);
  const u=xf*xf*(3-2*xf), v=yf*yf*(3-2*yf);
  return ( (v00*(1-u) + v10*u)*(1-v) + (v01*(1-u) + v11*u)*v );
}
function biomeAt(x,y){
  const n = smoothNoise(x*0.0015, y*0.0015);
  if(n < 0.33) return 0;
  if(n < 0.66) return 1;
  return 2;
}
const BIOMES = [
  {id:0,name:'–õ—É–≥',color:'#9AE6B4',types:['slime','slime_big']},
  {id:1,name:'–õ–µ—Å',color:'#5EEAD4',types:['wolf','wolf_fast']},
  {id:2,name:'–ü—Ä–æ–∫–ª—è—Ç—ã–π',color:'#FCA5A5',types:['imp','demon','fiend']}
];

/* Chunk functions: ensure/generate with more varied objects */
function chunkKey(cx,cy){ return cx + ',' + cy; }
function ensureChunk(cx,cy){
  const key = chunkKey(cx,cy);
  if(state.chunks.has(key)) return state.chunks.get(key);
  const chunk = {cx,cy,objects:[],created:now(),alpha:0,creating:true};
  state.chunks.set(key, chunk);
  setTimeout(()=> generateChunk(chunk), 10 + Math.random()*120); // staggered
  return chunk;
}
function generateChunk(chunk){
  if(!chunk || (!chunk.creating && chunk.objects.length)) return;
  chunk.creating = false;
  const baseX = chunk.cx * CONFIG.CHUNK, baseY = chunk.cy * CONFIG.CHUNK;
  const centerX = baseX + CONFIG.CHUNK/2, centerY = baseY + CONFIG.CHUNK/2;
  const bId = biomeAt(centerX, centerY);
  chunk.biome = bId;
  // varied object count but smaller than before to reduce clutter
  const base = 4 + Math.floor(Math.abs(hash(chunk.cx,chunk.cy))*5);
  const count = base;
  for(let i=0;i<count;i++){
    const rx = baseX + Math.random()*CONFIG.CHUNK;
    const ry = baseY + Math.random()*CONFIG.CHUNK;
    const r = Math.random();
    // introduce many different object types
    let type;
    if(r < 0.35) type = 'tree_small';
    else if(r < 0.55) type = 'tree_tall';
    else if(r < 0.7) type = 'bush';
    else if(r < 0.82) type = 'rock';
    else if(r < 0.9) type = 'ruin';
    else if(r < 0.95) type = 'fence';
    else type = 'pond';
    // varied radius per type
    const sizeMap = {tree_small:18, tree_tall:30, bush:10, rock:14, ruin:28, fence:12, pond:44};
    const size = sizeMap[type] || 14;
    chunk.objects.push({type, x: rx, y: ry, r: size, seed: Math.random()});
  }
  chunk.created = now();
  chunk.alpha = 0;
}

/* preload chunks around player to avoid pop-in */
function preloadAround(){
  const pcx = Math.floor(state.player.x / CONFIG.CHUNK), pcy = Math.floor(state.player.y / CONFIG.CHUNK);
  for(let dx=-CONFIG.PRELOAD_RADIUS; dx<=CONFIG.PRELOAD_RADIUS; dx++){
    for(let dy=-CONFIG.PRELOAD_RADIUS; dy<=CONFIG.PRELOAD_RADIUS; dy++){
      ensureChunk(pcx+dx, pcy+dy);
    }
  }
}

/* collision helpers (circle-based) */
function collidesStruct(x,y){
  const cx = Math.floor(x / CONFIG.CHUNK), cy = Math.floor(y / CONFIG.CHUNK);
  for(let dx=-1;dx<=1;dx++){
    for(let dy=-1;dy<=1;dy++){
      const ch = state.chunks.get(chunkKey(cx+dx, cy+dy));
      if(!ch) continue;
      for(const o of ch.objects){
        const d = Math.hypot(x - o.x, y - o.y);
        if(d < o.r + 10) return {hit:true, object:o, dist:d};
      }
    }
  }
  return {hit:false};
}

/* tryMove with fractional steps + push-out to reduce sharp stucks */
function tryMoveEntity(e, nx, ny){
  // quick test
  const col = collidesStruct(nx, ny);
  if(!col.hit){ e.x = nx; e.y = ny; return true; }
  // fractional sliding attempts
  const steps = 6;
  for(let s=steps; s>0; s--){
    const fx = e.x + (nx - e.x) * (s/steps);
    const fy = e.y + (ny - e.y) * (s/steps);
    if(!collidesStruct(fx, fy).hit){ e.x = fx; e.y = fy; return true; }
  }
  // push-out: compute overlap with nearest object and try nudge outward
  if(col.hit){
    const o = col.object;
    const d = Math.max(0.0001, col.dist);
    const overlap = (o.r + 10) - d;
    if(overlap > 0){
      const nx2 = e.x + (e.x - o.x) / d * (overlap + 1.5);
      const ny2 = e.y + (e.y - o.y) / d * (overlap + 1.5);
      if(!collidesStruct(nx2, ny2).hit){ e.x = nx2; e.y = ny2; return true; }
    }
  }
  return false;
}

/* safe spawn point (not inside object and not too near player) */
function findSpawn(minR=220, tries=50){
  for(let i=0;i<tries;i++){
    const a = Math.random()*Math.PI*2;
    const r = minR + Math.random()*300;
    const x = state.player.x + Math.cos(a)*r;
    const y = state.player.y + Math.sin(a)*r;
    if(!collidesStruct(x,y).hit) return {x,y};
  }
  // fallback
  const a = Math.random()*Math.PI*2;
  return {x: state.player.x + Math.cos(a)*350, y: state.player.y + Math.sin(a)*350};
}

/* monster factory with assortment */
function spawnMonster(kind, x, y, boss=false){
  const templates = {
    slime:{hp:34, speed:0.45, atk:3, size:14},
    slime_big:{hp:60, speed:0.36, atk:5, size:20},
    wolf:{hp:24, speed:1.18, atk:4, size:12},
    wolf_fast:{hp:16, speed:1.6, atk:3, size:10},
    imp:{hp:30, speed:0.95, atk:3, size:12, ranged:true},
    demon:{hp:88, speed:0.6, atk:10, size:18},
    fiend:{hp:110, speed:0.7, atk:12, size:20},
    boss:{hp:420, speed:0.5, atk:18, size:34}
  };
  const tpl = templates[kind] || templates.slime;
  const ang = Math.random()*Math.PI*2;
  const sx = (x===undefined) ? state.player.x + Math.cos(ang)*(300 + Math.random()*200) : x;
  const sy = (y===undefined) ? state.player.y + Math.sin(ang)*(300 + Math.random()*200) : y;
  const m = { id: Math.random().toString(36).slice(2,9), type:kind, x:sx, y:sy, vx:0, vy:0, kbx:0, kby:0,
              hp: Math.round(tpl.hp * state.difficulty), maxHp: Math.round(tpl.hp * state.difficulty),
              atk: Math.round(tpl.atk * state.difficulty), speed: tpl.speed, size: tpl.size, ranged: !!tpl.ranged,
              hitCd:0, flash:0, boss:!!boss, anim:{t:Math.random()*1000} };
  state.monsters.push(m);
  return m;
}

/* initial monsters spawn */
for(let i=0;i<CONFIG.INITIAL_MONSTERS;i++){
  const p = findSpawn(200,60);
  // choose by current (0) biome or random
  const types = BIOMES[biomeAt(0,0)].types;
  spawnMonster(types[Math.floor(Math.random()*types.length)], p.x, p.y);
}

/* controls */
let keys = {};
addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

/* movement: smooth, with left/right facing only */
function movePlayer(dt){
  const p = state.player;
  let ax=0, ay=0;
  if(keys['a']||keys['arrowleft']) ax -= 1;
  if(keys['d']||keys['arrowright']) ax += 1;
  if(keys['w']||keys['arrowup']) ay -= 1;
  if(keys['s']||keys['arrowdown']) ay += 1;
  const len = Math.hypot(ax,ay);
  if(len > 0.001){
    ax /= len; ay /= len;
    const tx = ax * p.speed, ty = ay * p.speed;
    p.vx = lerp(p.vx||0, tx, 0.18); p.vy = lerp(p.vy||0, ty, 0.18);
    tryMoveEntity(p, p.x + p.vx * dt/16, p.y + p.vy * dt/16);
    if(Math.abs(p.vx) > 0.12) p.facing = p.vx < 0 ? -1 : 1;
  } else {
    p.vx = lerp(p.vx||0, 0, 0.14); p.vy = lerp(p.vy||0, 0, 0.14);
    tryMoveEntity(p, p.x + p.vx * dt/16, p.y + p.vy * dt/16);
  }
}

/* auto-attack */
function playerAutoAttack(){
  const p = state.player;
  if(p.atkCd > 0) { p.atkCd--; return; }
  let target=null, minD=Infinity;
  for(const m of state.monsters){
    const d = Math.hypot(m.x - p.x, m.y - p.y);
    if(d <= p.atkRange + m.size && d < minD){ minD = d; target = m; }
  }
  if(target){
    const dmg = p.atk + Math.floor(Math.random()*2);
    target.hp -= dmg;
    const dx = target.x - p.x, dy = target.y - p.y, dd = Math.max(1, Math.hypot(dx,dy));
    target.kbx = (dx/dd)*6; target.kby = (dy/dd)*6;
    target.flash = 10;
    // damage popup as particle
    state.particles.push({type:'num', x:target.x, y:target.y - target.size - 6, vx: rand(-0.4,0.4), vy:-1.2, text:'-' + dmg, life:700, created: now()});
    p.atkCd = Math.max(10, 20 - Math.floor(p.lvl/2));
  }
}

/* monster AI */
function updateMonsters(dt){
  const p = state.player;
  if(state.monsters.length > CONFIG.MAX_MONSTERS) state.monsters.length = CONFIG.MAX_MONSTERS;
  for(let i=state.monsters.length-1;i>=0;i--){
    const m = state.monsters[i];
    // simple pursuit with avoidance
    const dx = p.x - m.x, dy = p.y - m.y;
    const d = Math.hypot(dx,dy) || 1;
    let vx = (dx/d) * m.speed, vy = (dy/d) * m.speed;
    // avoid other monsters a bit
    for(const o of state.monsters){
      if(o === m) continue;
      const ddx = m.x - o.x, ddy = m.y - o.y; const dd = Math.hypot(ddx,ddy) || 1;
      if(dd < (m.size + o.size) * 0.9){ vx += (ddx/dd) * 0.45; vy += (ddy/dd) * 0.45; }
    }
    m.vx = lerp(m.vx||0, vx, 0.12); m.vy = lerp(m.vy||0, vy, 0.12);
    tryMoveEntity(m, m.x + (m.vx + (m.kbx||0)) * dt/16, m.y + (m.vy + (m.kby||0)) * dt/16);
    m.kbx *= 0.86; m.kby *= 0.86;

    // ranged projectile
    if(m.ranged && Math.random() < 0.004 + state.wave * 0.0008){
      const ang = Math.atan2(p.y - m.y, p.x - m.x);
      state.particles.push({type:'proj', x:m.x, y:m.y, vx:Math.cos(ang)*3.1, vy:Math.sin(ang)*3.1, dmg: Math.max(1, Math.round(m.atk*0.12)), life:1000, created: now()});
    }

    // attack on contact (with cooldown and if player not invul)
    if(d < m.size + 14 && m.hitCd <= 0){
      if(p.invul <= 0){
        const hit = Math.max(1, Math.round(m.atk * 0.6));
        p.hp -= hit; p.invul = 36;
        state.particles.push({type:'num', x:p.x, y:p.y - 20, vx:rand(-0.6,0.6), vy:-1.1, text:'-' + hit, life:700, created: now()});
        p.x += (p.x - m.x)/d * 6; p.y += (p.y - m.y)/d * 6;
      }
      m.hitCd = 70 + Math.random()*20;
    }
    if(m.hitCd>0) m.hitCd--;
    if(m.flash>0) m.flash--;
    // death
    if(m.hp <= 0){
      // coin drops
      const drop = 2 + Math.floor(Math.random()*3);
      for(let k=0;k<drop && state.coins.length < CONFIG.MAX_COINS; k++){
        state.coins.push({ x: m.x + rand(-8,8), y: m.y + rand(-8,8), vx: rand(-1.6,1.6), vy: rand(-3,-1), created: now(), life:6000, size:4 + Math.random()*3 });
      }
      state.player.exp = (state.player.exp || 0) + Math.round(m.maxHp / 8);
      state.particles.push({type:'num', x:m.x, y:m.y-8, vx:0, vy:-0.8, text:'+XP', life:900, created:now()});
      state.monsters.splice(i,1);
      continue;
    }
    if(Math.hypot(m.x - p.x, m.y - p.y) > 3500) state.monsters.splice(i,1);
  }
}

/* particles */
function spawnParticles(x,y,count){ for(let i=0;i<count;i++){ state.particles.push({type:'hit', x:x+rand(-6,6), y:y+rand(-6,6), vx:rand(-2,2), vy:rand(-2,-0.5), life:600+Math.random()*300, created:now()}); } }
function updateParticles(dt){
  for(let i=state.particles.length-1;i>=0;i--){
    const p = state.particles[i];
    p.x += (p.vx||0) * dt/16; p.y += (p.vy||0) * dt/16;
    p.vy += 0.06 * dt/16;
    if(now() - p.created > (p.life || 600)) state.particles.splice(i,1);
    if(p.type === 'proj'){
      const d = Math.hypot(p.x - state.player.x, p.y - state.player.y);
      if(d < 14 && state.player.invul <= 0){
        state.player.hp -= p.dmg || 2; state.player.invul = 36; state.particles.splice(i,1); continue;
      }
    }
  }
  if(state.particles.length > CONFIG.MAX_PARTICLES) state.particles.splice(0, state.particles.length - CONFIG.MAX_PARTICLES);
}

/* coins */
function updateCoins(dt){
  for(let i=state.coins.length-1;i>=0;i--){
    const c = state.coins[i];
    c.vy += 0.08 * dt/16; c.x += c.vx * dt/16; c.y += c.vy * dt/16;
    const dx = state.player.x - c.x, dy = state.player.y - c.y; const d = Math.hypot(dx,dy) || 1;
    if(d < 120) { c.vx += (dx/d) * 0.25 * dt/16; c.vy += (dy/d) * 0.25 * dt/16; }
    if(d < 12){ state.player.gold += 1; state.particles.push({type:'coin', x:c.x, y:c.y, vx:0, vy:-1, life:400, created:now()}); state.coins.splice(i,1); continue; }
    if(now() - c.created > c.life) state.coins.splice(i,1);
  }
  if(state.coins.length > CONFIG.MAX_COINS) state.coins.length = CONFIG.MAX_COINS;
}

/* waves & leveling */
function spawnWave(n){
  for(let i=0;i<n;i++){
    const p = findSpawn(220, 50);
    const bId = biomeAt(state.player.x + rand(-40,40), state.player.y + rand(-40,40));
    const types = BIOMES[bId].types;
    const type = types[Math.floor(Math.random()*types.length)];
    spawnMonster(type, p.x, p.y);
  }
}
function maybeSpawnWave(){
  if(now() - state.lastWaveAt >= CONFIG.WAVE_INTERVAL){
    state.wave++; state.lastWaveAt = now();
    const count = Math.min(60, 4 + state.wave + Math.floor(state.wave*0.5));
    spawnWave(count);
    if(state.wave % 7 === 0){
      const p = findSpawn(320, 80); spawnMonster('boss', p.x, p.y, true);
    }
    state.player.gold += Math.round(state.wave * 0.7);
  }
}
function updateLeveling(){
  if(!state.player.exp) state.player.exp = 0;
  const need = state.player.lvl * 50;
  if(state.player.exp >= need){
    state.player.exp -= need; state.player.lvl++;
    state.player.maxHp += 10; state.player.hp = Math.min(state.player.maxHp, state.player.hp + 12);
    if(state.player.lvl % 5 === 0) state.difficulty *= 1.12;
    // show banner
    UI.levelBanner.style.display = 'block';
    UI.levelBanner.style.opacity = '1';
    setTimeout(()=>{ UI.levelBanner.style.transition='opacity 900ms ease, transform 900ms ease'; UI.levelBanner.style.opacity='0'; UI.levelBanner.style.transform='translateX(-50%) translateY(-12px) scale(.96)'; }, 700);
    setTimeout(()=>{ UI.levelBanner.style.display = 'none'; UI.levelBanner.style.transition=''; UI.levelBanner.style.transform='translateX(-50%)'; UI.levelBanner.style.opacity='1'; }, 1500);
  }
}

/* save/load (player-only) */
function saveGame(){ try{ const s = {player:state.player, inventory:state.inventory, wave:state.wave, difficulty:state.difficulty, startedAt:state.startedAt}; localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(s)); }catch(e){}}
function loadGame(){ try{ const s = JSON.parse(localStorage.getItem(CONFIG.SAVE_KEY)); if(s){ state.player = Object.assign(state.player, s.player); state.inventory = s.inventory || state.inventory; state.wave = s.wave || state.wave; state.difficulty = s.difficulty || state.difficulty; state.startedAt = s.startedAt || state.startedAt; } }catch(e){}}
loadGame(); setInterval(saveGame, 5000);

/* drawing: respect TILE = 32 for crisp visuals */
function drawWorld(){
  const camX = state.player.x, camY = state.player.y;
  const tile = CONFIG.TILE;
  const cols = Math.ceil((canvas.width/CONFIG.DPR)/tile) + 4;
  const rows = Math.ceil((canvas.height/CONFIG.DPR)/tile) + 4;
  const startX = Math.floor((camX - (canvas.width/CONFIG.DPR)/2) / tile) - 1;
  const startY = Math.floor((camY - (canvas.height/CONFIG.DPR)/2) / tile) - 1;
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const wx = (startX + x) * tile + tile/2;
      const wy = (startY + y) * tile + tile/2;
      const bi = BIOMES[biomeAt(wx,wy)];
      ctx.fillStyle = bi.color;
      const sx = Math.round((x * tile) - ((camX - (canvas.width/CONFIG.DPR)/2) % tile));
      const sy = Math.round((y * tile) - ((camY - (canvas.height/CONFIG.DPR)/2) % tile));
      ctx.fillRect(sx, sy, tile+1, tile+1);
      // light texture to remove flatness
      if((x+y)%3===0){ ctx.fillStyle = 'rgba(0,0,0,0.02)'; ctx.fillRect(sx+4, sy+4, 6,6); }
    }
  }
  // draw chunk objects with fade-in and distinct visuals
  const pcx = Math.floor(camX / CONFIG.CHUNK), pcy = Math.floor(camY / CONFIG.CHUNK);
  for(let dx=-CONFIG.PRELOAD_RADIUS-1; dx<=CONFIG.PRELOAD_RADIUS+1; dx++){
    for(let dy=-CONFIG.PRELOAD_RADIUS-1; dy<=CONFIG.PRELOAD_RADIUS+1; dy++){
      const ch = ensureChunk(pcx+dx, pcy+dy);
      if(!ch) continue;
      const age = Math.max(0, now() - (ch.created || now()));
      ch.alpha = Math.min(1, age / CONFIG.CHUNK_FADE_MS);
      for(const o of ch.objects){
        const sx = Math.round((canvas.width/CONFIG.DPR)/2 + (o.x - camX));
        const sy = Math.round((canvas.height/CONFIG.DPR)/2 + (o.y - camY));
        if(sx < -160 || sx > canvas.width/CONFIG.DPR + 160 || sy < -160 || sy > canvas.height/CONFIG.DPR + 160) continue;
        ctx.globalAlpha = ch.alpha;
        // distinct render per type with small pixel detail
        if(ch.alpha < 0.5){ ctx.fillStyle='rgba(0,0,0,0.08)'; ctx.fillRect(sx-6,sy-6,12,12); }
        else {
          if(o.type==='tree_small'){ ctx.fillStyle='#7c4a1f'; ctx.fillRect(sx-3, sy-10, 6, 10); ctx.fillStyle='#14532d'; ctx.fillRect(sx-10, sy-20, 20, 14); }
          else if(o.type==='tree_tall'){ ctx.fillStyle='#5b3a16'; ctx.fillRect(sx-4, sy-18, 8, 18); ctx.fillStyle='#064e3b'; ctx.fillRect(sx-18, sy-36, 36, 26); }
          else if(o.type==='bush'){ ctx.fillStyle='#14532d'; ctx.fillRect(sx-10, sy-6, 20, 12); ctx.fillStyle='#0b3a25'; ctx.fillRect(sx-4, sy-2, 8, 4); }
          else if(o.type==='rock'){ ctx.fillStyle='#6b7280'; ctx.fillRect(sx - Math.floor(o.r/2), sy - Math.floor(o.r/2), o.r, o.r); }
          else if(o.type==='ruin'){ ctx.fillStyle='#44403c'; ctx.fillRect(sx - o.r/1.6, sy - o.r/2, o.r*1.6, o.r/1.2); ctx.fillStyle='#2b2b2b'; ctx.fillRect(sx - 6, sy - o.r/4, 12, o.r/6); }
          else if(o.type==='fence'){ ctx.fillStyle='#8b5e34'; ctx.fillRect(sx-12, sy-6, 24, 4); ctx.fillRect(sx-10, sy-10, 4, 10); ctx.fillRect(sx+6, sy-10, 4, 10); }
          else if(o.type==='pond'){ ctx.fillStyle='#38bdf8'; ctx.beginPath(); ctx.ellipse(sx,sy,o.r,o.r*0.6,0,0,Math.PI*2); ctx.fill(); }
        }
        ctx.globalAlpha = 1;
      }
    }
  }
}

/* draw player with clearer pixels (facing left/right only) */
function drawPlayer(){
  const cx = canvas.width/(2*CONFIG.DPR), cy = canvas.height/(2*CONFIG.DPR);
  const p = state.player;
  const bob = Math.sin(now()/160)*1.6;
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.36)'; ctx.beginPath(); ctx.ellipse(cx, cy+18, 18, 8, 0, 0, Math.PI*2); ctx.fill();
  // legs
  ctx.fillStyle = '#0f1724'; ctx.fillRect(cx-9, cy+6+bob, 5, 10); ctx.fillRect(cx+4, cy+6+bob, 5, 10);
  // body
  ctx.fillStyle = '#1e3ea8'; ctx.fillRect(cx-10, cy-6+bob, 20, 18);
  // head
  ctx.fillStyle = '#fbe7c4'; ctx.beginPath(); ctx.ellipse(cx, cy-12+bob, 7.6, 7.6, 0,0,Math.PI*2); ctx.fill();
  // eyes
  ctx.fillStyle = '#081018';
  if(p.facing < 0){ ctx.fillRect(cx-5, cy-14+bob, 2,2); ctx.fillRect(cx-2, cy-14+bob,2,2); }
  else { ctx.fillRect(cx+2, cy-14+bob,2,2); ctx.fillRect(cx+5, cy-14+bob,2,2); }
  // sword (on side)
  ctx.save(); ctx.translate(cx, cy+bob);
  const swing = Math.max(0, (p.atkCd || 0) - 6) / 12;
  if(p.facing > 0){ ctx.fillStyle='#c7c7c7'; ctx.fillRect(12 + swing*6, -3, 30 - swing*10, 6); ctx.fillStyle='#6b7280'; ctx.fillRect(40 - swing*8, -2, 4,4); }
  else { ctx.fillStyle='#c7c7c7'; ctx.fillRect(-42 - swing*6, -3, 30 - swing*10, 6); ctx.fillStyle='#6b7280'; ctx.fillRect(-44 + swing*8, -2, 4,4); }
  ctx.restore();
}

/* draw monsters (improved detail and presence) */
function drawMonsters(){
  const cx = canvas.width/(2*CONFIG.DPR), cy = canvas.height/(2*CONFIG.DPR);
  ctx.font = '11px monospace';
  for(const m of state.monsters){
    const sx = cx + (m.x - state.player.x), sy = cy + (m.y - state.player.y);
    if(sx < -200 || sx > canvas.width/CONFIG.DPR + 200) continue;
    const bob = Math.sin((now() + (m.anim?.t||0))/200)*2;
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.26)'; ctx.beginPath(); ctx.ellipse(sx, sy+10, m.size*0.7, m.size*0.35, 0,0,Math.PI*2); ctx.fill();
    // body by type
    if(m.type.startsWith('slime')){ ctx.fillStyle = m.flash ? '#fff' : '#12b76a'; ctx.beginPath(); ctx.ellipse(sx, sy + bob, m.size, m.size*0.88,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#04121a'; ctx.fillRect(sx-4, sy-2+bob, 2,2); ctx.fillRect(sx+2, sy-2+bob, 2,2); }
    else if(m.type.startsWith('wolf')){ ctx.fillStyle = m.flash ? '#fff' : '#7c3aed'; ctx.fillRect(sx - m.size, sy - m.size + bob, m.size*2, m.size*2); }
    else if(m.type==='imp'){ ctx.fillStyle = m.flash ? '#fff' : '#f97316'; ctx.beginPath(); ctx.moveTo(sx,sy-m.size+bob); ctx.lineTo(sx+m.size,sy+m.size+bob); ctx.lineTo(sx-m.size,sy+m.size+bob); ctx.closePath(); ctx.fill(); }
    else { ctx.fillStyle = m.flash ? '#fff' : '#ef4444'; ctx.beginPath(); ctx.ellipse(sx, sy + bob, m.size*1.05, m.size*0.95, 0,0,Math.PI*2); ctx.fill(); }
    // hp bar
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(sx - m.size, sy - m.size - 12, m.size*2, 6);
    ctx.fillStyle = '#10b981'; ctx.fillRect(sx - m.size + 1, sy - m.size - 11, Math.max(0, (m.hp / m.maxHp) * (m.size*2 - 2)), 4);
    // hp number
    ctx.fillStyle = '#fff'; ctx.fillText(Math.max(0, Math.floor(m.hp)), sx - 8, sy - m.size - 16);
  }
}

/* draw coins/particles */
function drawCoins(){
  const cx = canvas.width/(2*CONFIG.DPR), cy = canvas.height/(2*CONFIG.DPR);
  for(const c of state.coins){
    const sx = cx + (c.x - state.player.x), sy = cy + (c.y - state.player.y);
    if(sx < -160 || sx > canvas.width/CONFIG.DPR + 160) continue;
    ctx.fillStyle = '#facc15'; ctx.beginPath(); ctx.arc(sx, sy, c.size, 0, Math.PI*2); ctx.fill();
  }
}
function drawParticles(){
  const cx = canvas.width/(2*CONFIG.DPR), cy = canvas.height/(2*CONFIG.DPR);
  ctx.textAlign = 'center';
  for(const p of state.particles){
    const sx = cx + (p.x - state.player.x), sy = cy + (p.y - state.player.y);
    if(p.type === 'hit'){ ctx.fillStyle='rgba(255,200,100,0.9)'; ctx.fillRect(sx,sy,2,2); }
    if(p.type === 'coin'){ ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillRect(sx,sy-6,2,2); }
    if(p.type === 'proj'){ ctx.fillStyle='#f97316'; ctx.fillRect(sx-2,sy-2,4,4); }
    if(p.type === 'num' && p.text){ ctx.fillStyle = '#fff'; ctx.font = '12px monospace'; ctx.fillText(p.text, sx, sy); }
  }
}

/* draw minimap */
function drawMinimap(){
  const mw = minimap.width / CONFIG.DPR, mh = minimap.height / CONFIG.DPR;
  mctx.clearRect(0,0,mw,mh);
  const px = state.player.x, py = state.player.y;
  for(let y=0;y<mh;y++){
    for(let x=0;x<mw;x++){
      const wx = px + (x - mw/2) * 20;
      const wy = py + (y - mh/2) * 20;
      const b = BIOMES[biomeAt(wx,wy)];
      mctx.fillStyle = b.color; mctx.fillRect(x,y,1,1);
    }
  }
  const pcx = Math.floor(px / CONFIG.CHUNK), pcy = Math.floor(py / CONFIG.CHUNK);
  for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++){
    const ch = state.chunks.get(chunkKey(pcx+dx, pcy+dy));
    if(!ch) continue;
    for(const o of ch.objects){
      const rx = Math.round(mw/2 + (o.x - px)/20), ry = Math.round(mh/2 + (o.y - py)/20);
      if(rx>=0 && rx<mw && ry>=0 && ry<mh){ mctx.fillStyle = '#000'; mctx.fillRect(rx,ry,2,2); }
    }
  }
  for(const m of state.monsters){
    const rx = Math.round(mw/2 + (m.x - px)/20), ry = Math.round(mh/2 + (m.y - py)/20);
    if(rx>=0 && rx<mw && ry>=0 && ry<mh){ mctx.fillStyle = m.boss ? '#ff0' : '#fff'; mctx.fillRect(rx,ry,2,2); }
  }
  mctx.fillStyle = '#2563eb'; mctx.fillRect(Math.floor(mw/2)-1, Math.floor(mh/2)-1, 3, 3);
}

/* main loop */
let last = now();
function mainLoop(ts){
  const dt = Math.min(40, ts - last); last = ts;
  if(state.running){
    preloadAround();
    movePlayer(dt);
    playerAutoAttack();
    updateMonsters(dt);
    updateParticles(dt);
    updateCoins(dt);
    maybeSpawnWave();
    updateLeveling();
    // death
    if(state.player.hp <= 0){
      state.running = false;
      document.getElementById('gameoverStats').innerHTML = `Level: ${state.player.lvl}<br>Wave: ${state.wave}<br>Gold: ${state.player.gold}`;
      document.getElementById('gameoverModal').style.display = 'block';
    }
  }
  // clear & draw
  ctx.clearRect(0,0, canvas.width/CONFIG.DPR, canvas.height/CONFIG.DPR);
  drawWorld();
  drawMonsters();
  drawPlayer();
  drawCoins();
  drawParticles();
  drawMinimap();
  // update ui
  UI.hp.textContent = Math.max(0, Math.floor(state.player.hp)) + '/' + state.player.maxHp;
  UI.atk.textContent = state.player.atk;
  UI.lvl.textContent = state.player.lvl;
  UI.xp.textContent = (state.player.exp || 0) + '/' + (state.player.lvl * 50);
  UI.gold.textContent = state.player.gold;
  UI.biome.textContent = BIOMES[biomeAt(state.player.x, state.player.y)].name;
  UI.time.textContent = Math.floor((now() - state.startedAt)/1000);
  UI.wavePanel.textContent = 'Wave: ' + state.wave;
  requestAnimationFrame(mainLoop);
}
requestAnimationFrame(mainLoop);

/* schedule wave spawns */
setInterval(()=> maybeSpawnWave(), 1000);
setInterval(()=> updateLeveling(), 1000);

/* UI handlers */
document.getElementById('btnShop').addEventListener('click', ()=> UI.shopModal.style.display = 'block');
document.getElementById('shopClose').addEventListener('click', ()=> UI.shopModal.style.display = 'none');
document.querySelectorAll('#shopModal [data-buy]').forEach(btn=>{
  btn.addEventListener('click', (e)=>{
    const t = e.target.getAttribute('data-buy');
    if(t==='atk' && state.player.gold >= 20){ state.player.gold -= 20; state.player.atk += 1; }
    if(t==='hp' && state.player.gold >= 30){ state.player.gold -= 30; state.player.maxHp += 12; state.player.hp += 12; }
    if(t==='potion' && state.player.gold >= 15){ state.player.gold -= 15; state.inventory.potions = (state.inventory.potions||0) + 1; document.getElementById('invPotions').textContent = state.inventory.potions; }
    UI.shopModal.style.display = 'none';
  });
});
document.getElementById('btnInv').addEventListener('click', ()=> { UI.invModal.style.display = UI.invModal.style.display === 'block' ? 'none' : 'block'; document.getElementById('invPotions').textContent = state.inventory.potions || 0; });
document.getElementById('usePotion').addEventListener('click', ()=> { if(state.inventory.potions > 0){ state.inventory.potions--; state.player.hp = Math.min(state.player.maxHp, state.player.hp + 80); UI.invModal.style.display = 'none'; } else alert('–ù–µ—Ç —Ö–∏–ª–æ–∫'); });
document.getElementById('btnReset').addEventListener('click', ()=> { if(confirm('–ù–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É?')) startNewRun(); });
document.getElementById('goRestart').addEventListener('click', ()=> startNewRun());

/* restart */
function startNewRun(){
  state.player = { x:0,y:0,vx:0,vy:0,facing:1,hp:160,maxHp:160,atk:10,atkCd:0,atkRange:48,speed:3.0,invul:0,lvl:1,exp:0,gold:0 };
  state.inventory = {potions:2};
  state.monsters = []; state.coins = []; state.particles = []; state.chunks.clear();
  state.wave = 1; state.lastWaveAt = now(); state.running = true; state.difficulty = 1; state.startedAt = now();
  UI.shopModal.style.display = 'none'; UI.invModal.style.display = 'none'; UI.gameover.style.display = 'none';
  for(let i=0;i<CONFIG.INITIAL_MONSTERS;i++){ const p = findSpawn(220,60); const types = BIOMES[biomeAt(0,0)].types; spawnMonster(types[Math.floor(Math.random()*types.length)], p.x, p.y); }
}
startNewRun();

/* expose dev helpers */
window.SAVE = saveGame; window.LOAD = loadGame; window.PRINT_STATE = ()=> console.log(state);
</script>
</body>
</html>
