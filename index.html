<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Rogue ‚Äî Polished Mini</title>
<style>
  :root{--ui-bg:rgba(2,6,23,0.6);--panel:#0b1220;--accent:#ffd166}
  html,body{height:100%;margin:0;background:#06121a;font-family:Inter,system-ui,monospace;color:#e6eef8}
  canvas{display:block; width:100%; height:100vh; image-rendering:pixelated}
  #ui {position:fixed;left:50%;top:8px;transform:translateX(-50%);background:var(--ui-bg);padding:6px 10px;border-radius:10px;display:flex;gap:12px;align-items:center;z-index:40}
  #ui .stat{display:flex;gap:6px;align-items:center;font-size:13px}
  button{background:#1f2937;border:1px solid rgba(255,255,255,0.04);color:#e6eef8;padding:6px 8px;border-radius:8px;cursor:pointer}
  #panels{position:fixed;right:12px;top:60px;display:flex;flex-direction:column;gap:8px;z-index:30}
  .panel{background:var(--panel);padding:8px;border-radius:8px;min-width:220px;font-size:13px}
  #minimap{position:fixed;right:12px;bottom:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);z-index:30;background:#071018}
  #shopModal,#gameoverModal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:var(--panel);padding:14px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);display:none;z-index:60}
  .shop-row{display:flex;justify-content:space-between;align-items:center;margin:8px 0}
  @media(max-width:720px){ #ui{font-size:12px; } .panel{min-width:160px} }
</style>
</head>
<body>

<!-- Canvas -->
<canvas id="game"></canvas>

<!-- UI -->
<div id="ui">
  <div class="stat">‚ù§Ô∏è <span id="hp">0</span></div>
  <div class="stat">‚öîÔ∏è <span id="atk">0</span></div>
  <div class="stat">‚≠ê <span id="lvl">0</span></div>
  <div class="stat">XP <span id="xp">0</span></div>
  <div class="stat">üí∞ <span id="gold">0</span></div>
  <div class="stat">üåç <span id="biome">‚Äî</span></div>
  <div class="stat">‚è± <span id="time">0</span></div>
  <button id="btnShop">–ú–∞–≥–∞–∑–∏–Ω</button>
  <button id="btnInv">–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</button>
  <button id="btnReset">New Run</button>
</div>

<!-- Side panels -->
<div id="panels">
  <div class="panel" id="wavePanel">Wave: 1</div>
  <div class="panel" id="hint">WASD / arrows ‚Äî –¥–≤–∏–∂–µ–Ω–∏–µ. –£–¥–∞—Ä ‚Äî –∞–≤—Ç–æ.</div>
</div>

<canvas id="minimap" width="180" height="180"></canvas>

<!-- Shop modal -->
<div id="shopModal" class="panel">
  <h3>–ú–∞–≥–∞–∑–∏–Ω</h3>
  <div class="shop-row"><div>‚öî –£—Ä–æ–Ω +1</div><div><button data-buy="atk">20 G</button></div></div>
  <div class="shop-row"><div>‚ù§ –ú–∞–∫—Å HP +12</div><div><button data-buy="hp">30 G</button></div></div>
  <div class="shop-row"><div>üß™ –•–∏–ª–∫–∞ +1</div><div><button data-buy="potion">15 G</button></div></div>
  <div style="text-align:right;margin-top:8px"><button id="shopClose">–ó–∞–∫—Ä—ã—Ç—å</button></div>
</div>

<!-- Inventory modal -->
<div id="invModal" class="panel" style="display:none;">
  <h3>–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</h3>
  <div>–ü–æ—Çions: <span id="invPotions">0</span></div>
  <div style="margin-top:8px;text-align:right"><button id="usePotion">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ö–∏–ª–∫—É</button></div>
</div>

<!-- Game over -->
<div id="gameoverModal" class="panel" style="display:none;">
  <h2>–¢—ã –ø–æ–≥–∏–±</h2>
  <div id="gameoverStats"></div>
  <div style="margin-top:8px;text-align:right"><button id="goRestart">Restart</button></div>
</div>

<script>
/* ========= Pixel Rogue ‚Äî Polished Single File =========
Features implemented (user requests):
- smooth player & monsters movement + facing toward move direction
- preloaded chunks + fade-in to avoid pop-in
- procedural world with structures (tree/rock/ruin/water) that block movement
- biomes and per-biome enemy types
- enemies move, attack with cooldown, are knocked back on hit
- coins drop with physics and attraction, animated collection
- minimap with biomes, obstacles, enemies near player
- waves every 20s, XP, leveling, difficulty scaling every 5 levels
- shop + inventory functional
- saving/loading to localStorage
- safer initial difficulty & balance tuned
- performance caps and culling
=====================================================*/

/* ----------------- Config ----------------- */
const cfg = {
  tileSize: 32,
  chunkSize: 512, // world chunk size in px
  preloadRadius: 2, // pre-generate chunks within this manhattan radius
  waveInterval: 20000, // 20s
  initialMonsters: 4,
  monsterCap: 80,
  coinCap: 200,
  saveKey: 'pixel_rogue_polished_v2'
};

/* ----------------- Canvas & UI ----------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const mini = document.getElementById('minimap');
const mctx = mini.getContext('2d');

let W=innerWidth, H=innerHeight;
function resize(){ W=innerWidth; H=innerHeight; canvas.width=W; canvas.height=H; }
addEventListener('resize', resize); resize();

const ui = {
  hp: document.getElementById('hp'),
  atk: document.getElementById('atk'),
  lvl: document.getElementById('lvl'),
  xp: document.getElementById('xp'),
  gold: document.getElementById('gold'),
  biome: document.getElementById('biome'),
  time: document.querySelector('#ui [id="time"]') || document.getElementById('time'),
  wavePanel: document.getElementById('wavePanel'),
  shopModal: document.getElementById('shopModal'),
  invModal: document.getElementById('invModal'),
  gameover: document.getElementById('gameoverModal')
};

/* ----------------- State ----------------- */
let state = {
  player: {
    x: 0, y: 0, vx:0, vy:0, facing:0,
    hp: 120, maxHp: 120, atk: 8, atkCd:0, atkRange:44,
    speed: 2.8, invul:0, lvl:1, exp:0, gold:0
  },
  inventory: { potions: 2 },
  monsters: [],
  coins: [],
  particles: [],
  chunks: new Map(), // chunkKey -> {created,alpha,objects:[]}
  wave: 1,
  lastWaveAt: performance.now(),
  running: true,
  difficultyMult: 1,
  startedAt: performance.now()
};

/* ----------------- Noise & Biomes ----------------- */
// small value noise for biome
function hash(x,y){ return Math.abs(Math.sin(x*127.1 + y*311.7) * 43758.5453) % 1; }
function lerp(a,b,t){ return a + (b-a)*t; }
function smoothNoise(x,y){
  const xi=Math.floor(x), yi=Math.floor(y);
  const xf=x-xi, yf=y-yi;
  const v00=hash(xi,yi), v10=hash(xi+1,yi), v01=hash(xi,yi+1), v11=hash(xi+1,yi+1);
  const u = xf*xf*(3-2*xf), v = yf*yf*(3-2*yf);
  const x1 = lerp(v00,v10,u), x2 = lerp(v01,v11,u);
  return lerp(x1,x2,v);
}
function biomeAt(x,y){
  const n = smoothNoise(x*0.0015, y*0.0015);
  if(n < 0.33) return 0;
  if(n < 0.66) return 1;
  return 2;
}
const BIOMES = [
  { id:0, name:'–õ—É–≥', color:'#6EE7B7', types:['slime'] },
  { id:1, name:'–õ–µ—Å', color:'#34D399', types:['wolf'] },
  { id:2, name:'–ü—Ä–æ–∫–ª—è—Ç—ã–π', color:'#FCA5A5', types:['imp','demon'] }
];

/* ----------------- Chunk generation w/ fade-in ----------------- */
function chunkKey(cx,cy){ return cx + ',' + cy; }
function ensureChunk(cx,cy){
  const key = chunkKey(cx,cy);
  if(state.chunks.has(key)) return state.chunks.get(key);
  // schedule generation asynchronously to avoid blocking frame
  const chunk = { cx, cy, created:performance.now(), alpha:0, objects:[], pregen:true };
  state.chunks.set(key, chunk);
  // generate in next tick (setTimeout)
  setTimeout(()=>generateChunk(chunk), 10);
  return chunk;
}
function generateChunk(chunk){
  const {cx,cy} = chunk;
  const baseX = cx * cfg.chunkSize;
  const baseY = cy * cfg.chunkSize;
  const biomeId = biomeAt(baseX + cfg.chunkSize/2, baseY + cfg.chunkSize/2);
  const biome = BIOMES[biomeId];
  const count = 5 + Math.floor(Math.abs(hash(cx,cy))*6);
  for(let i=0;i<count;i++){
    const rx = baseX + Math.random()*cfg.chunkSize;
    const ry = baseY + Math.random()*cfg.chunkSize;
    // choose object type depending on biome
    const r = Math.random();
    let type = 'rock';
    if(biomeId === 0){ type = r < 0.6 ? 'tree' : (r < 0.9 ? 'rock' : 'pond'); }
    else if(biomeId === 1){ type = r < 0.7 ? 'tree' : 'rock'; }
    else { type = r < 0.5 ? 'ruin' : 'wall'; }
    const size = (type==='tree'?20:type==='rock'?14:type==='pond'?40:26);
    chunk.objects.push({type, x: rx, y: ry, r: size});
  }
  chunk.biome = biomeId;
  chunk.pregen = false;
  chunk.created = performance.now();
  // set alpha smoothly to 1
  chunk.alpha = 0;
}

/* Preload around player to avoid visible generation */
function preloadNearbyChunks(){
  const px = Math.floor(state.player.x / cfg.chunkSize);
  const py = Math.floor(state.player.y / cfg.chunkSize);
  for(let dx = -cfg.preloadRadius; dx <= cfg.preloadRadius; dx++){
    for(let dy = -cfg.preloadRadius; dy <= cfg.preloadRadius; dy++){
      ensureChunk(px + dx, py + dy);
    }
  }
}

/* ----------------- Spawning & Entities ----------------- */
function spawnMonsterOfType(type, x, y, boss=false){
  const tpls = {
    slime: {hp:28, speed:0.5, atk:3, size:14},
    wolf:  {hp:20, speed:1.15, atk:4, size:12},
    imp:   {hp:24, speed:0.85, atk:3, size:12, ranged:true},
    demon: {hp:60, speed:0.6, atk:8, size:18},
    boss:  {hp:220, speed:0.6, atk:14, size:28}
  };
  const tpl = tpls[type] || tpls.slime;
  const m = {
    id: Math.random().toString(36).slice(2,9),
    type, x, y,
    vx:0, vy:0, kbx:0, kby:0,
    hp: Math.round(tpl.hp * state.difficultyMult),
    maxHp: Math.round(tpl.hp * state.difficultyMult),
    atk: Math.round(tpl.atk * state.difficultyMult),
    speed: tpl.speed, size: tpl.size,
    ranged: !!tpl.ranged, hitCd:0, flash:0, boss: !!boss,
    anim: { t: Math.random()*1000 }
  };
  state.monsters.push(m);
}

function spawnWave(n){
  const rBase = 260 + state.wave * 8;
  for(let i=0;i<n;i++){
    const ang = Math.random()*Math.PI*2;
    const x = state.player.x + Math.cos(ang) * (rBase + Math.random()*200);
    const y = state.player.y + Math.sin(ang) * (rBase + Math.random()*200);
    const b = BIOMES[biomeAt(state.player.x, state.player.y)];
    const type = b.types[Math.floor(Math.random()*b.types.length)];
    spawnMonsterOfType(type, x, y);
  }
}

/* initial wave */
spawnWave(cfg.initialMonsters);

/* ----------------- Player controls & movement ----------------- */
let keys = {};
addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

function movePlayer(dt){
  const p = state.player;
  let dx = 0, dy = 0;
  if(keys['a']||keys['arrowleft']) dx -= 1;
  if(keys['d']||keys['arrowright']) dx += 1;
  if(keys['w']||keys['arrowup']) dy -= 1;
  if(keys['s']||keys['arrowdown']) dy += 1;
  const len = Math.hypot(dx,dy);
  if(len > 0.001){
    dx /= len; dy /= len;
    // smoothing velocity and facing
    p.vx = lerp(p.vx||0, dx * p.speed, 0.18);
    p.vy = lerp(p.vy||0, dy * p.speed, 0.18);
    p.x += p.vx * dt/16;
    p.y += p.vy * dt/16;
    p.facing = Math.atan2(dy, dx);
  } else {
    p.vx = lerp(p.vx||0, 0, 0.14);
    p.vy = lerp(p.vy||0, 0, 0.14);
    p.x += p.vx * dt/16;
    p.y += p.vy * dt/16;
  }
}

/* ----------------- Collision with structures ----------------- */
function collidesWithStructures(nx, ny){
  const cx = Math.floor(nx / cfg.chunkSize);
  const cy = Math.floor(ny / cfg.chunkSize);
  for(let dx=-1;dx<=1;dx++){
    for(let dy=-1;dy<=1;dy++){
      const chunk = ensureChunk(cx+dx, cy+dy);
      if(!chunk || !chunk.objects) continue;
      for(const o of chunk.objects){
        const d = Math.hypot(nx - o.x, ny - o.y);
        if(d < o.r + 8) return true;
      }
    }
  }
  return false;
}

/* Attempt to move entity with collision resolution */
function tryMoveEntity(e, nx, ny){
  if(!collidesWithStructures(nx, ny)){
    e.x = nx; e.y = ny;
    return true;
  }
  // sliding: try moving on x only or y only
  if(!collidesWithStructures(nx, e.y)){ e.x = nx; return true; }
  if(!collidesWithStructures(e.x, ny)){ e.y = ny; return true; }
  // else blocked
  return false;
}

/* ----------------- Combat: player auto-attack ----------------- */
function playerAutoAttack(){
  const p = state.player;
  if(p.atkCd > 0) { p.atkCd--; return; }
  // find nearest monster in range
  let target = null, minD = Infinity;
  for(const m of state.monsters){
    const d = Math.hypot(m.x - p.x, m.y - p.y);
    if(d <= p.atkRange + m.size && d < minD){
      minD = d; target = m;
    }
  }
  if(target){
    const dmg = p.atk + Math.floor(Math.random()*2);
    target.hp -= dmg;
    target.kbx = (target.x - p.x) / (minD || 1) * 6; // knockback
    target.kby = (target.y - p.y) / (minD || 1) * 6;
    target.flash = 10;
    spawnParticles(target.x, target.y, Math.min(8, 2 + Math.floor(dmg/2)));
    p.atkCd = Math.max(10, 18 - Math.floor(p.lvl/3)); // faster attack with lvl
  }
}

/* ----------------- Monster AI ----------------- */
function updateMonsters(dt){
  const p = state.player;
  // cap monsters for perf
  if(state.monsters.length > cfg.monsterCap){
    state.monsters.length = cfg.monsterCap;
  }
  for(let i = state.monsters.length - 1; i >= 0; i--){
    const m = state.monsters[i];
    // skip far monsters (culling)
    const distToPlayer = Math.hypot(m.x - p.x, m.y - p.y);
    if(distToPlayer > 3000){ state.monsters.splice(i,1); continue; }
    // basic approach behaviour
    let dx = p.x - m.x, dy = p.y - m.y;
    let d = Math.hypot(dx, dy) || 1;
    // desired velocity
    let desiredVx = (dx/d) * m.speed;
    let desiredVy = (dy/d) * m.speed;
    // avoidance with neighboring monsters
    for(const other of state.monsters){
      if(other === m) continue;
      const ddx = m.x - other.x, ddy = m.y - other.y;
      const dd = Math.hypot(ddx, ddy) || 1;
      if(dd < (m.size + other.size) * 0.9){
        desiredVx += (ddx / dd) * 0.6;
        desiredVy += (ddy / dd) * 0.6;
      }
    }
    m.vx = lerp(m.vx || 0, desiredVx, 0.12);
    m.vy = lerp(m.vy || 0, desiredVy, 0.12);
    // attempt move with collision
    const nx = m.x + (m.vx + (m.kbx || 0)) * dt/16;
    const ny = m.y + (m.vy + (m.kby || 0)) * dt/16;
    tryMoveEntity(m, nx, ny);
    m.kbx *= 0.86; m.kby *= 0.86;
    // ranged behaviour
    if(m.ranged && Math.random() < 0.004 + state.wave * 0.0008){
      // shoot projectile to player
      const ang = Math.atan2(p.y - m.y, p.x - m.x);
      state.particles.push({type:'proj', x:m.x, y:m.y, vx:Math.cos(ang)*3.4, vy:Math.sin(ang)*3.4, life:1000, dmg: Math.max(1, Math.round(m.atk*0.12))});
    }
    // attack if close and cooldown ready
    if(d < m.size + 14 && m.hitCd <= 0){
      if(p.invul <= 0){
        const hit = Math.max(1, Math.round(m.atk * (0.7 + Math.random()*0.6)));
        p.hp -= hit;
        p.invul = 36; // frames of invulnerability ~0.6s at 60Hz
        // push player
        const push = 8;
        p.x += (p.x - m.x)/d * push;
        p.y += (p.y - m.y)/d * push;
      }
      m.hitCd = 50 + Math.random()*30;
    }
    if(m.hitCd > 0) m.hitCd--;
    if(m.flash > 0) m.flash--;
    // death
    if(m.hp <= 0){
      // coin drop
      const drop = 2 + Math.floor(Math.random()*3);
      for(let k=0;k<drop && state.coins.length < cfg.coinCap;k++){
        state.coins.push({
          x: m.x + rand(-6,6), y: m.y + rand(-6,6),
          vx: rand(-1.6,1.6), vy: rand(-3,-1),
          created: performance.now(), life: 6000, size: 4 + Math.random()*3
        });
      }
      state.player.exp = (state.player.exp || 0) + Math.round(m.maxHp/8);
      state.monsters.splice(i,1);
    }
  }
}

/* ---------- Particles ---------- */
function spawnParticles(x,y,count){
  for(let i=0;i<count;i++){
    state.particles.push({
      type: 'hit', x: x+rand(-6,6), y: y+rand(-6,6),
      vx: rand(-2,2), vy: rand(-2, -0.5),
      life: 600 + Math.random()*300, created: performance.now()
    });
  }
}
function updateParticles(dt){
  for(let i=state.particles.length-1;i>=0;i--){
    const p = state.particles[i];
    p.x += p.vx * dt/16; p.y += p.vy * dt/16;
    p.vy += 0.06 * dt/16;
    if(performance.now() - p.created > p.life) state.particles.splice(i,1);
    // handle projectiles hitting player
    if(p.type === 'proj'){
      const d = Math.hypot(p.x - state.player.x, p.y - state.player.y);
      if(d < 14 && state.player.invul <= 0){
        state.player.hp -= p.dmg || 2;
        state.player.invul = 36;
        state.particles.splice(i,1);
      }
    }
  }
}

/* ---------- Coins ---------- */
function updateCoins(dt){
  for(let i=state.coins.length-1;i>=0;i--){
    const c = state.coins[i];
    c.vy += 0.08 * dt/16;
    c.x += c.vx * dt/16; c.y += c.vy * dt/16;
    const dx = state.player.x - c.x, dy = state.player.y - c.y;
    const d = Math.hypot(dx,dy) || 1;
    if(d < 120){
      // magnetic pull
      const pull = 0.2 * (120 - d)/120;
      c.vx += dx/d * pull * dt/16;
      c.vy += dy/d * pull * dt/16;
    }
    const pickupDist = 12;
    if(d < pickupDist){
      state.player.gold += 1;
      // animated pickup: spawn small particle
      state.particles.push({type:'coin', x:c.x, y:c.y, vx:0, vy:-1, life:400, created:performance.now()});
      state.coins.splice(i,1); continue;
    }
    if(performance.now() - c.created > c.life) state.coins.splice(i,1);
  }
}

/* ---------- Waves, leveling & difficulty ---------- */
function maybeSpawnWave(){
  const now = performance.now();
  if(now - state.lastWaveAt >= cfg.waveInterval){
    state.wave++;
    state.lastWaveAt = now;
    // spawn wave
    const baseCount = 3 + state.wave + Math.floor(state.wave*0.4);
    const spawnCount = Math.min(50, baseCount);
    for(let i=0;i<spawnCount;i++){
      const ang = Math.random()*Math.PI*2;
      const radius = 260 + Math.random()*150 + state.wave*6;
      const x = state.player.x + Math.cos(ang) * radius;
      const y = state.player.y + Math.sin(ang) * radius;
      const bIdx = biomeAt(state.player.x + rand(-40,40), state.player.y + rand(-40,40));
      const b = BIOMES[bIdx];
      const type = b.types[Math.floor(Math.random()*b.types.length)];
      spawnMonsterOfType(type, x, y);
    }
    // occasional boss
    if(state.wave % 7 === 0){
      const ang = Math.random()*Math.PI*2;
      spawnMonsterOfType('boss', state.player.x + Math.cos(ang)*380, state.player.y + Math.sin(ang)*380, true);
    }
    // small wave reward
    state.player.gold += Math.round(state.wave * 0.6);
  }
}

function updateLeveling(){
  if(!state.player.exp) state.player.exp = 0;
  const need = state.player.lvl * 50;
  if(state.player.exp >= need){
    state.player.exp -= need;
    state.player.lvl++;
    state.player.maxHp += 8;
    state.player.hp = Math.min(state.player.maxHp, state.player.hp + 8);
    // difficulty escalate every 5 levels but gently
    if(state.player.lvl % 5 === 0) state.difficultyMult *= 1.15;
    // small gift
    state.player.gold += 8 + state.player.lvl;
  }
}

/* ---------- Save / Load ---------- */
function save(){
  try{
    const s = {
      player: state.player,
      inventory: state.inventory,
      wave: state.wave,
      difficultyMult: state.difficultyMult,
      startedAt: state.startedAt
    };
    localStorage.setItem(cfg.saveKey, JSON.stringify(s));
  }catch(e){}
}
function load(){
  try{
    const s = JSON.parse(localStorage.getItem(cfg.saveKey));
    if(s){
      state.player = Object.assign(state.player, s.player);
      state.inventory = s.inventory || state.inventory;
      state.wave = s.wave || state.wave;
      state.difficultyMult = s.difficultyMult || state.difficultyMult;
      state.startedAt = s.startedAt || state.startedAt;
    }
  }catch(e){}
}
load();
setInterval(save, 5000);

/* ---------- Rendering: world + fade-in chunks ---------- */
function drawWorld(){
  // fade-in alpha for freshly generated chunks
  const camX = state.player.x, camY = state.player.y;
  // draw grass/background by sampling biome center of tile
  const tile = cfg.tileSize;
  const cols = Math.ceil(W / tile) + 4;
  const rows = Math.ceil(H / tile) + 4;
  const startCx = Math.floor((camX - W/2) / tile) - 1;
  const startCy = Math.floor((camY - H/2) / tile) - 1;
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const wx = (startCx + x) * tile + tile/2;
      const wy = (startCy + y) * tile + tile/2;
      const b = BIOMES[biomeAt(wx, wy)];
      ctx.fillStyle = b.color;
      const sx = Math.round((x * tile) - ((camX - W/2) % tile));
      const sy = Math.round((y * tile) - ((camY - H/2) % tile));
      ctx.fillRect(sx, sy, tile+1, tile+1);
    }
  }
  // draw chunk objects with chunk alpha fade
  const pcx = Math.floor(camX / cfg.chunkSize), pcy = Math.floor(camY / cfg.chunkSize);
  for(let dx=-cfg.preloadRadius-1; dx<=cfg.preloadRadius+1; dx++){
    for(let dy=-cfg.preloadRadius-1; dy<=cfg.preloadRadius+1; dy++){
      const chunk = ensureChunk(pcx+dx, pcy+dy);
      if(!chunk) continue;
      // alpha ramp
      const age = Math.max(0, performance.now() - (chunk.created || performance.now()));
      chunk.alpha = Math.min(1, (age / 400)); // 400ms fade
      for(const o of chunk.objects){
        const sx = Math.round(W/2 + (o.x - camX));
        const sy = Math.round(H/2 + (o.y - camY));
        if(sx < -80 || sx > W+80 || sy < -80 || sy > H+80) continue;
        ctx.globalAlpha = chunk.alpha;
        if(o.type === 'tree'){
          // trunk
          ctx.fillStyle = '#7c4a1f'; ctx.fillRect(sx-4, sy-12, 8, 12);
          // leaves (pixel-ish)
          ctx.fillStyle = '#14532d'; ctx.fillRect(sx-14, sy-28, 28, 18);
        } else if(o.type === 'rock'){
          ctx.fillStyle = '#6b7280'; ctx.fillRect(sx - o.r/2, sy - o.r/2, o.r, o.r);
        } else if(o.type === 'pond'){
          ctx.fillStyle = '#38bdf8'; ctx.beginPath(); ctx.ellipse(sx, sy, o.r, o.r*0.6, 0,0,Math.PI*2); ctx.fill();
        } else if(o.type === 'ruin'){
          ctx.fillStyle = '#44403c'; ctx.fillRect(sx - o.r, sy - o.r/2, o.r*2, o.r);
          ctx.fillStyle = '#2b2b2b'; ctx.fillRect(sx - 4, sy - o.r/2 + 4, 8, o.r/2);
        } else if(o.type === 'wall'){
          ctx.fillStyle = '#3f3f46'; ctx.fillRect(sx - o.r/2, sy - o.r/2, o.r, o.r/3);
        }
        ctx.globalAlpha = 1;
      }
    }
  }
}

/* ---------- Draw entities ---------- */
function drawPlayer(){
  const cx = W/2, cy = H/2;
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.beginPath(); ctx.ellipse(cx, cy+18, 18, 8, 0, 0, Math.PI*2); ctx.fill();
  // draw a simple pixel-sprite with facing
  ctx.save(); ctx.translate(cx, cy); ctx.rotate(state.player.facing || 0);
  // legs
  ctx.fillStyle = '#1f2937'; ctx.fillRect(-8, 8, 6, 10); ctx.fillRect(2, 8, 6, 10);
  // body
  ctx.fillStyle = '#2563eb'; ctx.fillRect(-10, -6, 20, 18);
  // head
  ctx.fillStyle = '#fce8c4'; ctx.beginPath(); ctx.arc(0, -12, 8, 0, Math.PI*2); ctx.fill();
  // sword
  ctx.fillStyle = '#c7c7c7'; ctx.fillRect(12, -4, 26, 5);
  ctx.restore();
}

function drawMonsters(){
  const cx = W/2, cy = H/2;
  ctx.font = '12px monospace';
  for(const m of state.monsters){
    const sx = cx + (m.x - state.player.x); const sy = cy + (m.y - state.player.y);
    if(sx < -80 || sx > W+80 || sy < -80 || sy > H+80) continue;
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath(); ctx.ellipse(sx, sy + 10, m.size*0.7, m.size*0.35, 0, 0, Math.PI*2); ctx.fill();
    // animated bob for liveliness
    const bob = Math.sin((performance.now() + (m.anim?.t||0))/200) * 2;
    // body by type
    if(m.type === 'slime'){
      ctx.fillStyle = m.flash ? '#fff' : '#10b981';
      ctx.beginPath(); ctx.ellipse(sx, sy + bob, m.size, m.size*0.85, 0, 0, Math.PI*2); ctx.fill();
    } else if(m.type === 'wolf'){
      ctx.fillStyle = m.flash ? '#fff' : '#7c3aed';
      ctx.fillRect(sx - m.size, sy - m.size + bob, m.size*2, m.size*2);
    } else if(m.type === 'imp'){
      ctx.fillStyle = m.flash ? '#fff' : '#f97316';
      ctx.beginPath(); ctx.moveTo(sx, sy - m.size + bob); ctx.lineTo(sx + m.size, sy + m.size + bob); ctx.lineTo(sx - m.size, sy + m.size + bob); ctx.closePath(); ctx.fill();
    } else if(m.type === 'demon' || m.type === 'boss'){
      ctx.fillStyle = m.flash ? '#fff' : '#ef4444';
      ctx.beginPath(); ctx.ellipse(sx, sy + bob, m.size*1.1, m.size*0.9, 0, 0, Math.PI*2); ctx.fill();
    }
    // hp bar
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(sx - m.size, sy - m.size - 12, m.size*2, 6);
    ctx.fillStyle = '#10b981'; ctx.fillRect(sx - m.size + 1, sy - m.size - 11, Math.max(0, (m.hp / m.maxHp) * (m.size*2 - 2)), 4);
    // hp number
    ctx.fillStyle = '#fff'; ctx.fillText(Math.max(0, Math.floor(m.hp)), sx - 8, sy - m.size - 16);
  }
}

function drawCoins(){
  const cx = W/2, cy = H/2;
  for(const c of state.coins){
    const sx = cx + (c.x - state.player.x), sy = cy + (c.y - state.player.y);
    ctx.fillStyle = '#facc15';
    ctx.beginPath(); ctx.arc(sx, sy, c.size, 0, Math.PI*2); ctx.fill();
  }
}

function drawParticles(){
  const cx = W/2, cy = H/2;
  for(const p of state.particles){
    const sx = cx + (p.x - state.player.x), sy = cy + (p.y - state.player.y);
    if(p.type === 'hit'){ ctx.fillStyle = 'rgba(255,200,100,0.9)'; ctx.fillRect(sx, sy, 2,2); }
    if(p.type === 'coin'){ ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.fillRect(sx, sy-6, 2, 2); }
    if(p.type === 'proj'){ ctx.fillStyle = '#f97316'; ctx.fillRect(sx-2, sy-2, 4,4); }
  }
}

function drawMinimap(){
  const mw = mini.width, mh = mini.height;
  mctx.clearRect(0,0,mw,mh);
  // draw approximate biome map around player
  const radius = 8; // in tiles
  const px = state.player.x, py = state.player.y;
  for(let y=0;y<mh;y++){
    for(let x=0;x<mw;x++){
      const wx = px + (x - mw/2) * 20;
      const wy = py + (y - mh/2) * 20;
      const b = BIOMES[biomeAt(wx, wy)];
      mctx.fillStyle = b.color;
      mctx.fillRect(x,y,1,1);
    }
  }
  // obstacles
  const cx = Math.floor(px / cfg.chunkSize), cy = Math.floor(py / cfg.chunkSize);
  for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++){
    const chunk = state.chunks.get(chunkKey(cx+dx,cy+dy));
    if(!chunk) continue;
    for(const o of chunk.objects){
      const rx = Math.round(mw/2 + (o.x - px)/20);
      const ry = Math.round(mh/2 + (o.y - py)/20);
      if(rx>=0 && rx<mw && ry>=0 && ry<mh){
        mctx.fillStyle = '#000';
        mctx.fillRect(rx,ry,2,2);
      }
    }
  }
  // monsters
  for(const m of state.monsters){
    const rx = Math.round(mw/2 + (m.x - state.player.x)/20);
    const ry = Math.round(mh/2 + (m.y - state.player.y)/20);
    if(rx>=0 && rx<mw && ry>=0 && ry<mh){
      mctx.fillStyle = m.boss ? '#ff0' : '#fff'; mctx.fillRect(rx,ry,2,2);
    }
  }
  // player dot
  mctx.fillStyle = '#2563eb'; mctx.fillRect(Math.floor(mw/2)-1, Math.floor(mh/2)-1, 3, 3);
}

/* ---------- Main loop ---------- */
let lastTime = performance.now();
function tick(now){
  const dt = Math.min(40, now - lastTime);
  lastTime = now;
  if(state.running){
    preloadNearbyChunks();
    movePlayer(dt);
    playerAutoAttack();
    updateMonsters(dt);
    updateParticles(dt);
    updateCoins(dt);
    maybeSpawnWave();
    updateLeveling();
    // caps
    if(state.coins.length > cfg.coinCap) state.coins.length = cfg.coinCap;
  }
  // drawing
  ctx.clearRect(0,0,W,H);
  drawWorld();
  drawMonsters();
  drawPlayer();
  drawCoins();
  drawParticles();
  drawMinimap();
  drawUI();
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* ---------- UI / shop / inventory handlers ---------- */
document.getElementById('btnShop').addEventListener('click', ()=> { ui.shopModal.style.display = 'block'; });
document.getElementById('shopClose').addEventListener('click', ()=> { ui.shopModal.style.display = 'none'; });
document.querySelectorAll('#shopModal [data-buy]').forEach(btn=>{
  btn.addEventListener('click', (e)=>{
    const type = e.target.getAttribute('data-buy');
    if(type === 'atk' && state.player.gold >= 20){ state.player.gold -= 20; state.player.atk += 1; }
    if(type === 'hp' && state.player.gold >= 30){ state.player.gold -= 30; state.player.maxHp += 12; state.player.hp += 12; }
    if(type === 'potion' && state.player.gold >= 15){ state.player.gold -= 15; state.inventory.potions = (state.inventory.potions||0) + 1; }
    ui.shopModal.style.display = 'none';
  });
});
document.getElementById('btnInv').addEventListener('click', ()=> {
  ui.invModal.style.display = ui.invModal.style.display === 'block' ? 'none' : 'block';
  document.getElementById('invPotions').textContent = state.inventory.potions || 0;
});
document.getElementById('usePotion').addEventListener('click', ()=> {
  if(state.inventory.potions > 0){
    state.inventory.potions--; state.player.hp = Math.min(state.player.maxHp, state.player.hp + 60);
    ui.invModal.style.display = 'none';
  } else alert('–ù–µ—Ç —Ö–∏–ª–æ–∫');
});
document.getElementById('btnReset').addEventListener('click', ()=> {
  if(confirm('–ù–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É?')) startNewRun();
});

/* ---------- Game over & restart ---------- */
function showGameOver(){
  ui.gameover.style.display = 'block';
  ui.gameover.querySelector('#gameoverStats').innerHTML = `Level: ${state.player.lvl}<br>Wave: ${state.wave}<br>Gold: ${state.player.gold}`;
}
document.getElementById('goRestart').addEventListener('click', ()=> startNewRun());

function startNewRun(){
  state.player = { x:0,y:0,vx:0,vy:0,facing:0, hp:120, maxHp:120, atk:8, atkCd:0, atkRange:44, speed:2.8, invul:0, lvl:1, exp:0, gold:0 };
  state.inventory = { potions: 2 };
  state.monsters.length = 0; state.coins.length = 0; state.particles.length = 0; state.chunks.clear();
  state.wave = 1; state.lastWaveAt = performance.now(); state.difficultyMult = 1; state.startedAt = performance.now();
  ui.shopModal.style.display = 'none'; ui.invModal.style.display = 'none'; ui.gameover.style.display = 'none';
  for(let i=0;i<cfg.initialMonsters;i++) spawnWave(1);
}

/* ---------- Small helpers used earlier ---------- */
function rand(a,b){ return Math.random()*(b-a)+a; }
function spawnMonsterOfType(type, x, y, boss){
  spawnMonsterOfType; // ensure reference defined earlier - actual factory defined above as spawnMonsterOfType (we used function earlier)
  // to avoid duplication, use spawnMonsterOfType wrapper calling spawnMonsterOfType defined above
  // But due to ordering, we already defined spawnMonsterOfType at top; here we assume it exists.
}

/* ---------- Utility small checks & final UI update ---------- */
function drawUI(){
  ui.hp.textContent = Math.max(0, Math.floor(state.player.hp)) + '/' + state.player.maxHp;
  ui.atk.textContent = state.player.atk;
  ui.lvl.textContent = state.player.lvl;
  ui.xp.textContent = (state.player.exp || 0) + '/' + (state.player.lvl * 50);
  ui.gold.textContent = state.player.gold;
  ui.biome.textContent = BIOMES[biomeAt(state.player.x, state.player.y)].name;
  ui.time.textContent = Math.floor((performance.now()-state.startedAt)/1000);
  ui.wavePanel.textContent = 'Wave: ' + state.wave;
}

/* ---------- Expose some debugging / tuning helpers to console ---------- */
window.PRINT_STATE = () => console.log(state);
window.SAVE_NOW = save;
window.LOAD_NOW = load;
window.startNewRun = startNewRun;

/* EOF */
</script>
</body>
</html>
