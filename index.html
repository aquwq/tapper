<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Rogue ‚Äî Fixed</title>
<style>
  :root{--ui-bg:rgba(2,6,23,0.66);--panel:#0b1220;--accent:#ffd166}
  html,body{height:100%;margin:0;background:#071019;font-family:Inter,system-ui,monospace;color:#e6eef8}
  #game{display:block; width:100%; height:100vh; image-rendering:pixelated; background:linear-gradient(#07212a,#041019)}
  #ui {position:fixed;left:50%;top:8px;transform:translateX(-50%);background:var(--ui-bg);padding:6px 10px;border-radius:10px;display:flex;gap:12px;align-items:center;z-index:50}
  #ui .stat{display:flex;gap:6px;align-items:center;font-size:13px}
  button{background:#1f2937;border:1px solid rgba(255,255,255,0.04);color:#e6eef8;padding:6px 8px;border-radius:8px;cursor:pointer}
  #panels{position:fixed;right:12px;top:60px;display:flex;flex-direction:column;gap:8px;z-index:40}
  .panel{background:var(--panel);padding:8px;border-radius:8px;min-width:220px;font-size:13px}
  #minimap{position:fixed;right:12px;bottom:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);z-index:40;background:#071018;width:180px;height:180px}
  #shopModal,#invModal,#gameoverModal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:var(--panel);padding:14px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);display:none;z-index:60}
  .shop-row{display:flex;justify-content:space-between;align-items:center;margin:8px 0}
  @media(max-width:720px){ #ui{font-size:12px; } .panel{min-width:160px} #minimap{width:120px;height:120px} }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="ui">
  <div class="stat">‚ù§Ô∏è <span id="hp">0</span></div>
  <div class="stat">‚öîÔ∏è <span id="atk">0</span></div>
  <div class="stat">‚≠ê <span id="lvl">0</span></div>
  <div class="stat">XP <span id="xp">0</span></div>
  <div class="stat">üí∞ <span id="gold">0</span></div>
  <div class="stat">üåç <span id="biome">‚Äî</span></div>
  <div class="stat">‚è± <span id="time">0</span></div>
  <button id="btnShop">–ú–∞–≥–∞–∑–∏–Ω</button>
  <button id="btnInv">–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</button>
  <button id="btnReset">New Run</button>
</div>

<div id="panels">
  <div class="panel" id="wavePanel">Wave: 1</div>
  <div class="panel" id="hint">WASD / —Å—Ç—Ä–µ–ª–∫–∏ ‚Äî –¥–≤–∏–∂–µ–Ω–∏–µ. –£–¥–∞—Ä ‚Äî –∞–≤—Ç–æ.</div>
</div>

<canvas id="minimap"></canvas>

<!-- shop modal -->
<div id="shopModal">
  <h3>–ú–∞–≥–∞–∑–∏–Ω</h3>
  <div class="shop-row"><div>‚öî –£—Ä–æ–Ω +1</div><div><button data-buy="atk">20 G</button></div></div>
  <div class="shop-row"><div>‚ù§ –ú–∞–∫—Å HP +12</div><div><button data-buy="hp">30 G</button></div></div>
  <div class="shop-row"><div>üß™ –•–∏–ª–∫–∞ +1</div><div><button data-buy="potion">15 G</button></div></div>
  <div style="text-align:right;margin-top:10px"><button id="shopClose">–ó–∞–∫—Ä—ã—Ç—å</button></div>
</div>

<!-- inventory modal -->
<div id="invModal">
  <h3>–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</h3>
  <div>Potions: <span id="invPotions">0</span></div>
  <div style="margin-top:8px;text-align:right"><button id="usePotion">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ö–∏–ª–∫—É</button></div>
</div>

<!-- game over modal -->
<div id="gameoverModal">
  <h2>–¢—ã –ø–æ–≥–∏–±</h2>
  <div id="gameoverStats"></div>
  <div style="margin-top:8px;text-align:right"><button id="goRestart">Restart</button></div>
</div>

<script>
/* ===== Pixel Rogue ‚Äî Fixed & Polished Single File =====
Fixes applied:
- minimap layout bug (fixed CSS and canvas size)
- no duplicate / broken spawnMonsterOfType functions
- chunk generation: preload radius, async generateChunk, fade-in alpha, low-detail draw to avoid pop-in
- findSpawnPoint to avoid spawning inside obstacles
- tryMoveEntity fractional steps to avoid getting stuck
- monsters present and balanced (weaker early)
- invulnerability frames, attack cooldowns, particle/coin caps
- shop & inventory buttons fixed
- saving/loading player minimal state
*/

/* --------- Config --------- */
const cfg = {
  tileSize: 32,
  chunkSize: 512,
  preloadRadius: 3,         // preload radius (was too small)
  waveInterval: 20000,
  initialMonsters: 4,
  monsterCap: 80,
  coinCap: 200,
  particleCap: 400,
  chunkFadeMs: 600,
  saveKey: 'pixel_rogue_fixed_v1'
};

/* --------- Canvas & UI --------- */
const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
const minimap = document.getElementById('minimap'), mctx = minimap.getContext('2d');
let W = innerWidth, H = innerHeight;
function resize(){ W = innerWidth; H = innerHeight; canvas.width = W; canvas.height = H; minimap.width = parseInt(getComputedStyle(minimap).width); minimap.height = parseInt(getComputedStyle(minimap).height); }
addEventListener('resize', resize); resize();

const ui = {
  hp: document.getElementById('hp'),
  atk: document.getElementById('atk'),
  lvl: document.getElementById('lvl'),
  xp: document.getElementById('xp'),
  gold: document.getElementById('gold'),
  biome: document.getElementById('biome'),
  time: document.querySelector('#ui [id="time"]') || document.getElementById('time'),
  wavePanel: document.getElementById('wavePanel'),
  shopModal: document.getElementById('shopModal'),
  invModal: document.getElementById('invModal'),
  gameover: document.getElementById('gameoverModal')
};

/* --------- State --------- */
let state = {
  player: {
    x: 0, y: 0, vx:0, vy:0, facing:0,
    hp: 120, maxHp: 120, atk: 8, atkCd:0, atkRange:44,
    speed: 2.8, invul:0, lvl:1, exp:0, gold:0
  },
  inventory: { potions: 2 },
  monsters: [],
  coins: [],
  particles: [],
  chunks: new Map(),
  wave: 1,
  lastWaveAt: performance.now(),
  running: true,
  difficultyMult: 1,
  startedAt: performance.now()
};

/* --------- Noise & Biomes --------- */
function hash(x,y){ return Math.abs(Math.sin(x*127.1 + y*311.7) * 43758.5453) % 1; }
function lerp(a,b,t){ return a + (b-a)*t; }
function smoothNoise(x,y){
  const xi=Math.floor(x), yi=Math.floor(y);
  const xf=x-xi, yf=y-yi;
  const v00=hash(xi,yi), v10=hash(xi+1,yi), v01=hash(xi,yi+1), v11=hash(xi+1,yi+1);
  const u=xf*xf*(3-2*xf), v=yf*yf*(3-2*yf);
  return lerp( lerp(v00,v10,u), lerp(v01,v11,u), v );
}
function biomeAt(x,y){
  const n = smoothNoise(x*0.0016, y*0.0016);
  if(n < 0.33) return 0;
  if(n < 0.66) return 1;
  return 2;
}
const BIOMES = [
  {id:0,name:'–õ—É–≥',color:'#6EE7B7',types:['slime']},
  {id:1,name:'–õ–µ—Å',color:'#34D399',types:['wolf']},
  {id:2,name:'–ü—Ä–æ–∫–ª—è—Ç—ã–π',color:'#FCA5A5',types:['imp','demon']}
];

/* --------- Chunks (async safe) --------- */
function chunkKey(cx,cy){ return cx + ',' + cy; }
function ensureChunk(cx,cy){
  const key = chunkKey(cx,cy);
  if(state.chunks.has(key)) return state.chunks.get(key);
  const chunk = {cx,cy,creating:true,objects:[],alpha:0,created:performance.now(),biome:null};
  state.chunks.set(key, chunk);
  // generate async shortly to avoid frame blocking; setTimeout to stagger many requests
  setTimeout(()=>{ if(!chunk.pregen) generateChunk(chunk); }, 25 + Math.random()*120);
  return chunk;
}
function generateChunk(chunk){
  if(!chunk) return;
  // avoid re-generation
  if(!chunk.creating && chunk.objects.length) return;
  chunk.creating = false;
  const {cx,cy} = chunk;
  const baseX = cx * cfg.chunkSize, baseY = cy * cfg.chunkSize;
  const centerX = baseX + cfg.chunkSize/2, centerY = baseY + cfg.chunkSize/2;
  const bId = biomeAt(centerX, centerY);
  chunk.biome = bId;
  const count = 5 + Math.floor(Math.abs(hash(cx,cy))*6);
  for(let i=0;i<count;i++){
    const rx = baseX + Math.random()*cfg.chunkSize;
    const ry = baseY + Math.random()*cfg.chunkSize;
    const r = Math.random();
    let type = 'rock';
    if(bId === 0) type = r < 0.6 ? 'tree' : (r < 0.9 ? 'rock' : 'pond');
    else if(bId === 1) type = r < 0.7 ? 'tree' : 'rock';
    else type = r < 0.5 ? 'ruin' : 'wall';
    const size = (type==='tree'?20:type==='rock'?14:type==='pond'?40:26);
    chunk.objects.push({type, x: rx, y: ry, r: size});
  }
  chunk.created = performance.now();
  chunk.alpha = 0;
}

/* Preload neighbors gradually */
function preloadNearbyChunks(){
  const px = Math.floor(state.player.x / cfg.chunkSize);
  const py = Math.floor(state.player.y / cfg.chunkSize);
  for(let dx=-cfg.preloadRadius; dx<=cfg.preloadRadius; dx++){
    for(let dy=-cfg.preloadRadius; dy<=cfg.preloadRadius; dy++){
      ensureChunk(px + dx, py + dy);
    }
  }
}

/* --------- Spawn & entity factory (single working implementation) --------- */
function spawnMonsterOfType(type, x, y, boss=false){
  const templates = {
    slime: {hp:28, speed:0.5, atk:3, size:14},
    wolf:  {hp:20, speed:1.15, atk:4, size:12},
    imp:   {hp:24, speed:0.85, atk:3, size:12, ranged:true},
    demon: {hp:60, speed:0.6, atk:8, size:18},
    boss:  {hp:220, speed:0.6, atk:14, size:28}
  };
  const tpl = templates[type] || templates.slime;
  const angle = Math.random()*Math.PI*2;
  const sx = (x === undefined) ? state.player.x + Math.cos(angle) * (260 + Math.random()*160) : x;
  const sy = (y === undefined) ? state.player.y + Math.sin(angle) * (260 + Math.random()*160) : y;
  const m = {
    id: Math.random().toString(36).slice(2,9),
    type, x: sx, y: sy, vx:0, vy:0, kbx:0, kby:0,
    hp: Math.round(tpl.hp * state.difficultyMult),
    maxHp: Math.round(tpl.hp * state.difficultyMult),
    atk: Math.round(tpl.atk * state.difficultyMult),
    speed: tpl.speed, size: tpl.size, ranged: !!tpl.ranged,
    hitCd:0, flash:0, boss: !!boss, anim:{t:Math.random()*1000}
  };
  state.monsters.push(m);
  return m;
}

/* helper: find safe spawn point (not inside obstacles) */
function collidesWithStructuresAt(x,y){
  const cx = Math.floor(x / cfg.chunkSize), cy = Math.floor(y / cfg.chunkSize);
  for(let dx=-1;dx<=1;dx++){
    for(let dy=-1;dy<=1;dy++){
      const chunk = state.chunks.get(chunkKey(cx+dx,cy+dy));
      if(!chunk || !chunk.objects) continue;
      for(const o of chunk.objects){
        const d = Math.hypot(x - o.x, y - o.y);
        if(d < o.r + 10) return true;
      }
    }
  }
  return false;
}
function findSpawnPoint(minR=220, attempts=40){
  for(let i=0;i<attempts;i++){
    const a = Math.random()*Math.PI*2;
    const r = minR + Math.random()*260;
    const x = state.player.x + Math.cos(a)*r;
    const y = state.player.y + Math.sin(a)*r;
    if(!collidesWithStructuresAt(x,y)) return {x,y};
  }
  // fallback
  const a = Math.random()*Math.PI*2;
  return {x: state.player.x + Math.cos(a)*320, y: state.player.y + Math.sin(a)*320};
}

/* spawn wave using findSpawnPoint */
function spawnWave(n){
  for(let i=0;i<n;i++){
    const pos = findSpawnPoint();
    const bIdx = biomeAt(state.player.x + rand(-40,40), state.player.y + rand(-40,40));
    const type = BIOMES[bIdx].types[Math.floor(Math.random()*BIOMES[bIdx].types.length)];
    spawnMonsterOfType(type, pos.x, pos.y);
  }
}

/* initial gentle spawn */
for(let i=0;i<cfg.initialMonsters;i++) spawnWave(1);

/* --------- Controls / Movement ---------- */
let keys = {};
addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

function movePlayer(dt){
  const p = state.player;
  let dx=0, dy=0;
  if(keys['a']||keys['arrowleft']) dx -= 1;
  if(keys['d']||keys['arrowright']) dx += 1;
  if(keys['w']||keys['arrowup']) dy -= 1;
  if(keys['s']||keys['arrowdown']) dy += 1;
  const len = Math.hypot(dx,dy);
  if(len > 0.001){
    dx /= len; dy /= len;
    p.vx = lerp(p.vx||0, dx * p.speed, 0.18);
    p.vy = lerp(p.vy||0, dy * p.speed, 0.18);
    // predict next pos, attempt move with sliding
    const nx = p.x + p.vx * dt/16, ny = p.y + p.vy * dt/16;
    tryMoveEntity(p, nx, ny);
    p.facing = Math.atan2(dy, dx);
  } else {
    p.vx = lerp(p.vx||0, 0, 0.14); p.vy = lerp(p.vy||0, 0, 0.14);
    tryMoveEntity(p, p.x + p.vx * dt/16, p.y + p.vy * dt/16);
  }
}

/* tryMoveEntity: fractional step sliding to avoid getting stuck */
function tryMoveEntity(e, nx, ny){
  if(!collidesWithStructuresAt(nx, ny)){ e.x = nx; e.y = ny; return true; }
  // fractional sliding
  const steps = 4;
  for(let s=steps;s>0;s--){
    const fx = e.x + (nx - e.x) * (s/steps);
    const fy = e.y + (ny - e.y) * (s/steps);
    if(!collidesWithStructuresAt(fx, fy)){ e.x = fx; e.y = fy; return true; }
  }
  return false;
}

/* ---------- Combat (player auto-attack) ---------- */
function playerAutoAttack(){
  const p = state.player;
  if(p.atkCd > 0) { p.atkCd--; return; }
  let target = null, minD = Infinity;
  for(const m of state.monsters){
    const d = Math.hypot(m.x - p.x, m.y - p.y);
    if(d <= p.atkRange + m.size && d < minD){ minD = d; target = m; }
  }
  if(target){
    const dmg = p.atk + Math.floor(Math.random()*2);
    target.hp -= dmg;
    // knockback
    const dx = target.x - p.x, dy = target.y - p.y, d = Math.max(1, Math.hypot(dx,dy));
    target.kbx = (dx/d)*6; target.kby = (dy/d)*6;
    target.flash = 8;
    spawnParticles(target.x, target.y, Math.min(10, 2 + Math.floor(dmg/2)));
    p.atkCd = Math.max(10, 18 - Math.floor(p.lvl/3));
  }
}

/* ---------- Monster AI ---------- */
function updateMonsters(dt){
  const p = state.player;
  if(state.monsters.length > cfg.monsterCap) state.monsters.length = cfg.monsterCap;
  for(let i=state.monsters.length-1;i>=0;i--){
    const m = state.monsters[i];
    const dx = p.x - m.x, dy = p.y - m.y;
    const d = Math.hypot(dx,dy) || 1;
    // desired velocity toward player with slight avoidance
    let desiredVx = (dx/d)*m.speed, desiredVy = (dy/d)*m.speed;
    for(const other of state.monsters){
      if(other === m) continue;
      const ddx = m.x - other.x, ddy = m.y - other.y;
      const dd = Math.hypot(ddx,ddy) || 1;
      if(dd < (m.size + other.size)*0.9){
        desiredVx += (ddx/dd)*0.4; desiredVy += (ddy/dd)*0.4;
      }
    }
    m.vx = lerp(m.vx||0, desiredVx, 0.12);
    m.vy = lerp(m.vy||0, desiredVy, 0.12);
    const nx = m.x + (m.vx + (m.kbx||0))*dt/16;
    const ny = m.y + (m.vy + (m.kby||0))*dt/16;
    tryMoveEntity(m, nx, ny);
    m.kbx *= 0.86; m.kby *= 0.86;
    // ranged shoots
    if(m.ranged && Math.random() < 0.004 + state.wave*0.0008){
      const ang = Math.atan2(p.y - m.y, p.x - m.x);
      state.particles.push({type:'proj', x:m.x, y:m.y, vx:Math.cos(ang)*3.2, vy:Math.sin(ang)*3.2, life:1000, dmg: Math.max(1, Math.round(m.atk*0.12))});
    }
    // attack if close
    if(d < m.size + 14 && m.hitCd <= 0){
      if(p.invul <= 0){
        const hit = Math.max(1, Math.round(m.atk * 0.6));
        p.hp -= hit; p.invul = 36;
        // push player
        p.x += (p.x - m.x)/d * 6; p.y += (p.y - m.y)/d * 6;
      }
      m.hitCd = 70;
    }
    if(m.hitCd > 0) m.hitCd--;
    if(m.flash > 0) m.flash--;
    // death handling
    if(m.hp <= 0){
      // drop coins
      const drop = 2 + Math.floor(Math.random()*3);
      for(let k=0;k<drop && state.coins.length < cfg.coinCap;k++){
        state.coins.push({ x: m.x + rand(-8,8), y: m.y + rand(-8,8), vx: rand(-1.6,1.6), vy: rand(-3,-1), created: performance.now(), life: 6000, size: 4 + Math.random()*3 });
      }
      state.player.exp = (state.player.exp || 0) + Math.round(m.maxHp/8);
      state.monsters.splice(i,1);
      continue;
    }
    // culling: if too far, remove
    if(Math.hypot(m.x - p.x, m.y - p.y) > 3500) state.monsters.splice(i,1);
  }
}

/* ---------- Particles ---------- */
function spawnParticles(x,y,count){
  for(let i=0;i<count;i++){
    state.particles.push({ type:'hit', x: x + rand(-6,6), y: y + rand(-6,6), vx: rand(-2,2), vy: rand(-2,-0.5), life: 600 + Math.random()*300, created: performance.now() });
  }
}
function updateParticles(dt){
  for(let i=state.particles.length-1;i>=0;i--){
    const p = state.particles[i];
    p.x += p.vx * dt/16; p.y += p.vy * dt/16; p.vy += 0.06 * dt/16;
    if(performance.now() - p.created > p.life) state.particles.splice(i,1);
    if(state.particles.length > cfg.particleCap) state.particles.splice(0, state.particles.length - cfg.particleCap);
    // projectile collision
    if(p.type === 'proj'){
      const d = Math.hypot(p.x - state.player.x, p.y - state.player.y);
      if(d < 14 && state.player.invul <= 0){
        state.player.hp -= p.dmg || 2; state.player.invul = 36; state.particles.splice(i,1); continue;
      }
      // collide with monsters: optional (skip)
    }
  }
}

/* ---------- Coins ---------- */
function updateCoins(dt){
  for(let i=state.coins.length-1;i>=0;i--){
    const c = state.coins[i];
    c.vy += 0.08 * dt/16;
    c.x += c.vx * dt/16; c.y += c.vy * dt/16;
    const dx = state.player.x - c.x, dy = state.player.y - c.y;
    const d = Math.hypot(dx,dy) || 1;
    if(d < 120){
      const pull = 0.25 * (120 - d) / 120;
      c.vx += (dx/d) * pull * dt/16; c.vy += (dy/d) * pull * dt/16;
    }
    if(d < 12){
      state.player.gold += 1;
      state.particles.push({type:'coin',x:c.x,y:c.y,vx:0,vy:-1,life:400,created:performance.now()});
      state.coins.splice(i,1); continue;
    }
    if(performance.now() - c.created > c.life) state.coins.splice(i,1);
  }
  if(state.coins.length > cfg.coinCap) state.coins.length = cfg.coinCap;
}

/* ---------- Waves & leveling ---------- */
function maybeSpawnWave(){
  const now = performance.now();
  if(now - state.lastWaveAt >= cfg.waveInterval){
    state.wave++; state.lastWaveAt = now;
    const spawnCount = Math.min(50, 3 + state.wave + Math.floor(state.wave*0.4));
    for(let i=0;i<spawnCount;i++){
      const p = findSpawnPoint();
      const bIdx = biomeAt(state.player.x + rand(-40,40), state.player.y + rand(-40,40));
      const type = BIOMES[bIdx].types[Math.floor(Math.random()*BIOMES[bIdx].types.length)];
      spawnMonsterOfType(type, p.x, p.y);
    }
    if(state.wave % 7 === 0){
      const p = findSpawnPoint(320);
      spawnMonsterOfType('boss', p.x, p.y, true);
    }
    state.player.gold += Math.round(state.wave * 0.6);
  }
}

function updateLeveling(){
  if(!state.player.exp) state.player.exp = 0;
  const need = state.player.lvl * 50;
  if(state.player.exp >= need){
    state.player.exp -= need; state.player.lvl++; state.player.maxHp += 8; state.player.hp = Math.min(state.player.maxHp, state.player.hp + 8);
    if(state.player.lvl % 5 === 0) state.difficultyMult *= 1.12;
    state.player.gold += 8 + state.player.lvl;
  }
}

/* ---------- Save / Load (player-only) ---------- */
function save(){
  try{
    const s = { player: state.player, inventory: state.inventory, wave: state.wave, difficultyMult: state.difficultyMult, startedAt: state.startedAt };
    localStorage.setItem(cfg.saveKey, JSON.stringify(s));
  }catch(e){}
}
function load(){
  try{
    const s = JSON.parse(localStorage.getItem(cfg.saveKey));
    if(s){ state.player = Object.assign(state.player, s.player); state.inventory = s.inventory || state.inventory; state.wave = s.wave || state.wave; state.difficultyMult = s.difficultyMult || state.difficultyMult; state.startedAt = s.startedAt || state.startedAt; }
  }catch(e){}
}
load(); setInterval(save, 5000);

/* ---------- Drawing ---------- */
function drawWorld(){
  const camX = state.player.x, camY = state.player.y;
  // background tiles
  const tile = cfg.tileSize;
  const cols = Math.ceil(W / tile) + 4, rows = Math.ceil(H / tile) + 4;
  const startX = Math.floor((camX - W/2) / tile) - 1, startY = Math.floor((camY - H/2)/tile) - 1;
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const wx = (startX + x) * tile + tile/2;
      const wy = (startY + y) * tile + tile/2;
      const b = BIOMES[biomeAt(wx, wy)];
      ctx.fillStyle = b.color;
      const sx = Math.round((x * tile) - ((camX - W/2) % tile));
      const sy = Math.round((y * tile) - ((camY - H/2) % tile));
      ctx.fillRect(sx, sy, tile+1, tile+1);
    }
  }
  // chunk objects with fade-in and low-detail if alpha < 1
  const pcx = Math.floor(camX / cfg.chunkSize), pcy = Math.floor(camY / cfg.chunkSize);
  for(let dx=-cfg.preloadRadius-1; dx<=cfg.preloadRadius+1; dx++){
    for(let dy=-cfg.preloadRadius-1; dy<=cfg.preloadRadius+1; dy++){
      const key = chunkKey(pcx+dx, pcy+dy);
      const chunk = state.chunks.get(key);
      if(!chunk) continue;
      // alpha ramp
      const age = Math.max(0, performance.now() - (chunk.created || performance.now()));
      chunk.alpha = Math.min(1, (age / cfg.chunkFadeMs));
      for(const o of chunk.objects){
        const sx = Math.round(W/2 + (o.x - camX));
        const sy = Math.round(H/2 + (o.y - camY));
        if(sx < -100 || sx > W+100 || sy < -100 || sy > H+100) continue;
        ctx.globalAlpha = chunk.alpha;
        if(chunk.alpha < 0.6){
          // low-detail placeholder (silhouette) while fading
          ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(sx - 6, sy - 6, 12, 12);
        } else {
          if(o.type === 'tree'){
            ctx.fillStyle = '#7c4a1f'; ctx.fillRect(sx-4, sy-12,8,12);
            ctx.fillStyle = '#14532d'; ctx.fillRect(sx-14, sy-28,28,18);
          } else if(o.type === 'rock'){
            ctx.fillStyle = '#6b7280'; ctx.fillRect(sx - o.r/2, sy - o.r/2, o.r, o.r);
          } else if(o.type === 'pond'){
            ctx.fillStyle = '#38bdf8'; ctx.beginPath(); ctx.ellipse(sx,sy,o.r,o.r*0.6,0,0,Math.PI*2); ctx.fill();
          } else if(o.type === 'ruin'){
            ctx.fillStyle = '#44403c'; ctx.fillRect(sx - o.r, sy - o.r/2, o.r*2, o.r);
            ctx.fillStyle = '#2b2b2b'; ctx.fillRect(sx - 4, sy - o.r/2 + 4, 8, o.r/2);
          } else if(o.type === 'wall'){
            ctx.fillStyle = '#3f3f46'; ctx.fillRect(sx - o.r/2, sy - o.r/2, o.r, o.r/3);
          }
        }
        ctx.globalAlpha = 1;
      }
    }
  }
}

function drawPlayer(){
  const cx = W/2, cy = H/2;
  ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.beginPath(); ctx.ellipse(cx, cy+18, 18, 8, 0, 0, Math.PI*2); ctx.fill();
  ctx.save(); ctx.translate(cx, cy); ctx.rotate(state.player.facing || 0);
  ctx.fillStyle = '#1f2937'; ctx.fillRect(-8,8,6,10); ctx.fillRect(2,8,6,10);
  ctx.fillStyle = '#2563eb'; ctx.fillRect(-10,-6,20,18);
  ctx.fillStyle = '#fce8c4'; ctx.beginPath(); ctx.arc(0,-12,8,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#c7c7c7'; ctx.fillRect(12,-4,26,5);
  ctx.restore();
}

function drawMonsters(){
  const cx = W/2, cy = H/2;
  ctx.font = '12px monospace';
  for(const m of state.monsters){
    const sx = cx + (m.x - state.player.x), sy = cy + (m.y - state.player.y);
    if(sx < -100 || sx > W+100 || sy < -100 || sy > H+100) continue;
    ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.beginPath(); ctx.ellipse(sx, sy+10, m.size*0.7, m.size*0.35, 0,0,Math.PI*2); ctx.fill();
    const bob = Math.sin((performance.now() + (m.anim?.t||0))/200) * 2;
    if(m.type === 'slime'){ ctx.fillStyle = m.flash ? '#fff' : '#10b981'; ctx.beginPath(); ctx.ellipse(sx, sy + bob, m.size, m.size*0.85,0,0,Math.PI*2); ctx.fill(); }
    else if(m.type === 'wolf'){ ctx.fillStyle = m.flash ? '#fff' : '#7c3aed'; ctx.fillRect(sx - m.size, sy - m.size + bob, m.size*2, m.size*2); }
    else if(m.type === 'imp'){ ctx.fillStyle = m.flash ? '#fff' : '#f97316'; ctx.beginPath(); ctx.moveTo(sx,sy-m.size+bob); ctx.lineTo(sx+m.size,sy+m.size+bob); ctx.lineTo(sx-m.size,sy+m.size+bob); ctx.closePath(); ctx.fill(); }
    else { ctx.fillStyle = m.flash ? '#fff' : '#ef4444'; ctx.beginPath(); ctx.ellipse(sx, sy + bob, m.size*1.1, m.size*0.9,0,0,Math.PI*2); ctx.fill(); }
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(sx - m.size, sy - m.size - 12, m.size*2, 6);
    ctx.fillStyle = '#10b981'; ctx.fillRect(sx - m.size + 1, sy - m.size - 11, Math.max(0, (m.hp / m.maxHp) * (m.size*2 - 2)), 4);
    ctx.fillStyle = '#fff'; ctx.fillText(Math.max(0, Math.floor(m.hp)), sx - 8, sy - m.size - 16);
  }
}

function drawCoins(){ const cx = W/2, cy = H/2; for(const c of state.coins){ const sx = cx + (c.x - state.player.x), sy = cy + (c.y - state.player.y); if(sx < -100 || sx > W+100 || sy < -100 || sy > H+100) continue; ctx.fillStyle = '#facc15'; ctx.beginPath(); ctx.arc(sx, sy, c.size, 0, Math.PI*2); ctx.fill(); } }
function drawParticles(){ const cx = W/2, cy = H/2; for(const p of state.particles){ const sx = cx + (p.x - state.player.x), sy = cy + (p.y - state.player.y); if(p.type === 'hit'){ ctx.fillStyle='rgba(255,200,100,0.9)'; ctx.fillRect(sx,sy,2,2);} if(p.type==='coin'){ ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillRect(sx,sy-6,2,2);} if(p.type==='proj'){ ctx.fillStyle='#f97316'; ctx.fillRect(sx-2,sy-2,4,4);} } }

function drawMinimap(){
  const mw = minimap.width, mh = minimap.height;
  mctx.clearRect(0,0,mw,mh);
  const px = state.player.x, py = state.player.y;
  for(let y=0;y<mh;y++){
    for(let x=0;x<mw;x++){
      const wx = px + (x - mw/2) * 20;
      const wy = py + (y - mh/2) * 20;
      const b = BIOMES[biomeAt(wx,wy)];
      mctx.fillStyle = b.color; mctx.fillRect(x,y,1,1);
    }
  }
  // draw chunk objects
  const pcx = Math.floor(px / cfg.chunkSize), pcy = Math.floor(py / cfg.chunkSize);
  for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++){
    const chunk = state.chunks.get(chunkKey(pcx+dx,pcy+dy)); if(!chunk) continue;
    for(const o of chunk.objects){
      const rx = Math.round(mw/2 + (o.x - px)/20), ry = Math.round(mh/2 + (o.y - py)/20);
      if(rx>=0 && rx<mw && ry>=0 && ry<mh){ mctx.fillStyle = '#000'; mctx.fillRect(rx,ry,2,2); }
    }
  }
  for(const m of state.monsters){
    const rx = Math.round(mw/2 + (m.x - px)/20), ry = Math.round(mh/2 + (m.y - py)/20);
    if(rx>=0 && rx<mw && ry>=0 && ry<mh){ mctx.fillStyle = m.boss ? '#ff0' : '#fff'; mctx.fillRect(rx,ry,2,2); }
  }
  mctx.fillStyle = '#2563eb'; mctx.fillRect(Math.floor(mw/2)-1, Math.floor(mh/2)-1, 3, 3);
}

/* ---------- Main loop ---------- */
let last = performance.now();
function loop(now){
  const dt = Math.min(40, now - last);
  last = now;
  if(state.running){
    preloadNearbyChunks();
    movePlayer(dt);
    playerAutoAttack();
    updateMonsters(dt);
    updateParticles(dt);
    updateCoins(dt);
    maybeSpawnWave();
    updateLeveling();
    // simple death check
    if(state.player.hp <= 0){
      state.running = false; document.getElementById('gameoverStats').innerHTML = `Level: ${state.player.lvl}<br>Wave: ${state.wave}<br>Gold: ${state.player.gold}`; document.getElementById('gameoverModal').style.display = 'block';
    }
  }
  // draw
  ctx.clearRect(0,0,W,H);
  drawWorld();
  drawMonsters();
  drawPlayer();
  drawCoins();
  drawParticles();
  drawMinimap();
  // UI
  ui.hp.textContent = Math.max(0, Math.floor(state.player.hp)) + '/' + state.player.maxHp;
  ui.atk.textContent = state.player.atk;
  ui.lvl.textContent = state.player.lvl;
  ui.xp.textContent = (state.player.exp || 0) + '/' + (state.player.lvl * 50);
  ui.gold.textContent = state.player.gold;
  ui.biome.textContent = BIOMES[biomeAt(state.player.x, state.player.y)].name;
  ui.time.textContent = Math.floor((performance.now() - state.startedAt)/1000);
  ui.wavePanel.textContent = 'Wave: ' + state.wave;
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ---------- Helpers ---------- */
function rand(a,b){ return Math.random()*(b-a)+a; }

/* ---------- Wave & spawn wrappers to use safe findSpawnPoint ---------- */
function spawnMonsterSafe(type){
  const p = findSpawnPoint();
  spawnMonsterOfType(type, p.x, p.y);
}
function spawnWaveSafe(n){
  for(let i=0;i<n;i++) spawnMonsterSafe(BIOMES[biomeAt(state.player.x, state.player.y)].types[0]);
}

/* ---------- Shop / Inventory handlers ---------- */
document.getElementById('btnShop').addEventListener('click', ()=> { ui.shopModal.style.display = 'block'; });
document.getElementById('shopClose').addEventListener('click', ()=> { ui.shopModal.style.display = 'none'; });
document.querySelectorAll('#shopModal [data-buy]').forEach(btn=>{
  btn.addEventListener('click', (e)=>{
    const type = e.target.getAttribute('data-buy');
    if(type === 'atk' && state.player.gold >= 20){ state.player.gold -= 20; state.player.atk += 1; }
    if(type === 'hp' && state.player.gold >= 30){ state.player.gold -= 30; state.player.maxHp += 12; state.player.hp += 12; }
    if(type === 'potion' && state.player.gold >= 15){ state.player.gold -= 15; state.inventory.potions = (state.inventory.potions||0) + 1; }
    ui.shopModal.style.display = 'none';
  });
});
document.getElementById('btnInv').addEventListener('click', ()=> {
  ui.invModal.style.display = ui.invModal.style.display === 'block' ? 'none' : 'block';
  document.getElementById('invPotions').textContent = state.inventory.potions || 0;
});
document.getElementById('usePotion').addEventListener('click', ()=> {
  if(state.inventory.potions > 0){ state.inventory.potions--; state.player.hp = Math.min(state.player.maxHp, state.player.hp + 60); ui.invModal.style.display = 'none'; }
  else alert('–ù–µ—Ç —Ö–∏–ª–æ–∫');
});
document.getElementById('btnReset').addEventListener('click', ()=> {
  if(confirm('–ù–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É?')) startNewRun();
});

/* ---------- Game over handlers ---------- */
document.getElementById('goRestart').addEventListener('click', ()=> startNewRun());

function startNewRun(){
  state.player = { x:0,y:0,vx:0,vy:0,facing:0,hp:120,maxHp:120,atk:8,atkCd:0,atkRange:44,speed:2.8,invul:0,lvl:1,exp:0,gold:0 };
  state.inventory = { potions:2 };
  state.monsters.length = 0; state.coins.length = 0; state.particles.length = 0; state.chunks.clear();
  state.wave = 1; state.lastWaveAt = performance.now(); state.running = true; state.difficultyMult = 1; state.startedAt = performance.now();
  ui.shopModal.style.display = 'none'; ui.invModal.style.display = 'none'; ui.gameover.style.display = 'none';
  for(let i=0;i<cfg.initialMonsters;i++) spawnWave(1);
}

/* ---------- Misc: wave spawning scheduler ---------- */
setInterval(()=>{ maybeSpawnWave(); }, 1000);

/* expose quick debugging functions */
window.SAVE_NOW = save; window.LOAD_NOW = load; window.START_NEW = startNewRun;
</script>
</body>
</html>
