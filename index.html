<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Pixel Rogue</title>
<style>
html,body{margin:0;overflow:hidden;background:#000;font-family:monospace}
canvas{display:block}
#ui{
position:fixed;top:6px;left:50%;transform:translateX(-50%);
background:rgba(0,0,0,.6);color:#fff;padding:6px 10px;
border-radius:10px;font-size:14px
}
#gameover{
position:fixed;inset:0;display:none;
background:rgba(0,0,0,.85);color:#fff;
align-items:center;justify-content:center;flex-direction:column
}
button{padding:8px 14px;border:0;border-radius:8px;background:#2563eb;color:#fff}
#mini{position:fixed;right:8px;top:8px;border:2px solid #fff;background:#111}
</style>
</head>
<body>

<div id="ui">
‚ù§Ô∏è <span id="hp"></span>
‚öîÔ∏è <span id="atk"></span>
‚ú® <span id="lvl"></span>
üí∞ <span id="gold"></span>
üåç <span id="biome"></span>
</div>

<div id="gameover">
<h1>Game Over</h1>
<button onclick="restart()">Restart</button>
</div>

<canvas id="c"></canvas>
<canvas id="mini" width="140" height="140"></canvas>

<script>
const c=document.getElementById("c"),ctx=c.getContext("2d");
const mini=document.getElementById("mini"),mctx=mini.getContext("2d");
resize();onresize=resize;
function resize(){c.width=innerWidth;c.height=innerHeight;}

let keys={};
onkeydown=e=>keys[e.key]=1;
onkeyup=e=>keys[e.key]=0;

const CHUNK=512;
const chunks=new Map();

function biomeAt(x,y){
let d=Math.hypot(x,y);
if(d<2000)return {n:"–õ—É–≥",c:"#4ade80"};
if(d<4000)return {n:"–õ–µ—Å",c:"#16a34a"};
return {n:"–ü—Ä–æ–∫–ª—è—Ç—ã–π",c:"#7f1d1d"};
}

function getChunk(cx,cy){
let key=cx+","+cy;
if(chunks.has(key))return chunks.get(key);
let objs=[];
let biome=biomeAt(cx*CHUNK,cy*CHUNK).n;
let count=6+Math.random()*4|0;
for(let i=0;i<count;i++){
let t;
if(biome==="–õ—É–≥")t=Math.random()<0.6?"tree":"rock";
else if(biome==="–õ–µ—Å")t=Math.random()<0.7?"tree":"rock";
else t=Math.random()<0.5?"ruin":"wall";
objs.push({
type:t,
x:cx*CHUNK+Math.random()*CHUNK,
y:cy*CHUNK+Math.random()*CHUNK,
r:t==="tree"?18:t==="rock"?16:24
});
}
chunks.set(key,objs);
return objs;
}

let player,monsters,coins,difficulty;

function init(){
player={x:0,y:0,hp:120,maxHp:120,atk:8,speed:2.6,atkCd:0,inv:0,lvl:1,exp:0,gold:0};
monsters=[];coins=[];
difficulty=1;
spawnWave(3);
}
init();

function spawnWave(n){
for(let i=0;i<n;i++){
let a=Math.random()*Math.PI*2;
monsters.push({
x:player.x+Math.cos(a)*300,
y:player.y+Math.sin(a)*300,
hp:25*difficulty,maxHp:25*difficulty,
atk:2*difficulty,speed:0.7,
atkCd:0,kbx:0,kby:0
});
}
}

function collideEntity(e,nx,ny){
let cx=Math.floor(nx/CHUNK),cy=Math.floor(ny/CHUNK);
for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){
let objs=getChunk(cx+dx,cy+dy);
for(let o of objs){
let d=Math.hypot(nx-o.x,ny-o.y);
if(d<o.r+10)return false;
}
}
e.x=nx;e.y=ny;
return true;
}

function update(){
let dx=(keys.a||keys.ArrowLeft?-1:0)+(keys.d||keys.ArrowRight?1:0);
let dy=(keys.w||keys.ArrowUp?-1:0)+(keys.s||keys.ArrowDown?1:0);
let l=Math.hypot(dx,dy)||1;
let nx=player.x+dx/l*player.speed;
let ny=player.y+dy/l*player.speed;
collideEntity(player,nx,ny);

player.atkCd=Math.max(0,player.atkCd-1);
player.inv=Math.max(0,player.inv-1);

monsters.forEach(m=>{
let dx=player.x-m.x,dy=player.y-m.y;
let d=Math.hypot(dx,dy)||1;
let nx=m.x+dx/d*m.speed+m.kbx;
let ny=m.y+dy/d*m.speed+m.kby;
collideEntity(m,nx,ny);
m.kbx*=0.8;m.kby*=0.8;

if(d<32&&player.atkCd===0){
m.hp-=player.atk;
m.kbx=-dx/d*5;m.kby=-dy/d*5;
player.atkCd=18;
}
if(d<22&&m.atkCd<=0&&player.inv===0){
player.hp-=m.atk;
player.inv=40;m.atkCd=60;
}
m.atkCd--;
});

monsters=monsters.filter(m=>{
if(m.hp<=0){
coins.push({x:m.x,y:m.y,vx:0,vy:0});
player.exp+=10;
return false;
}
return true;
});

coins=coins.filter(c=>{
let d=Math.hypot(player.x-c.x,player.y-c.y);
if(d<16){player.gold++;return false}
c.vx+=(player.x-c.x)/d*0.08;
c.vy+=(player.y-c.y)/d*0.08;
c.x+=c.vx;c.y+=c.vy;
return true;
});

if(player.exp>=player.lvl*40){
player.exp=0;player.lvl++;
if(player.lvl%5===0)difficulty*=1.15;
spawnWave(2+player.lvl);
}

if(player.hp<=0)gameover.style.display="flex";
}

function draw(){
let b=biomeAt(player.x,player.y);
ctx.fillStyle=b.c;
ctx.fillRect(0,0,c.width,c.height);
let px=c.width/2,py=c.height/2;

// structures
let cx=Math.floor(player.x/CHUNK),cy=Math.floor(player.y/CHUNK);
for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){
let objs=getChunk(cx+dx,cy+dy);
objs.forEach(o=>{
let sx=px+(o.x-player.x),sy=py+(o.y-player.y);
ctx.fillStyle=o.type==="tree"?"#14532d":o.type==="rock"?"#6b7280":"#374151";
ctx.fillRect(sx-o.r,sy-o.r,o.r*2,o.r*2);
});
}

// player
ctx.fillStyle="#fde68a";
ctx.fillRect(px-4,py-12,8,8);
ctx.fillStyle="#2563eb";
ctx.fillRect(px-6,py-4,12,14);

// monsters
monsters.forEach(m=>{
let sx=px+(m.x-player.x),sy=py+(m.y-player.y);
ctx.fillStyle="#7c2d12";
ctx.fillRect(sx-6,sy-6,12,12);
});

// coins
ctx.fillStyle="#facc15";
coins.forEach(c=>{
ctx.fillRect(px+(c.x-player.x)-2,py+(c.y-player.y)-2,4,4);
});

// minimap
mctx.clearRect(0,0,140,140);
mctx.fillStyle=b.c;mctx.fillRect(0,0,140,140);
mctx.fillStyle="#000";
for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++){
getChunk(cx+dx,cy+dy).forEach(o=>{
let x=70+(o.x-player.x)/20,y=70+(o.y-player.y)/20;
if(x>0&&x<140&&y>0&&y<140)mctx.fillRect(x,y,2,2);
});
}
mctx.fillStyle="#fff";mctx.fillRect(68,68,4,4);
}

function loop(){
if(gameover.style.display!=="flex"){update();draw();}
hp.textContent=Math.floor(player.hp)+"/"+player.maxHp;
atk.textContent=player.atk;
lvl.textContent=player.lvl;
gold.textContent=player.gold;
biome.textContent=biomeAt(player.x,player.y).n;
requestAnimationFrame(loop);
}
loop();

function restart(){gameover.style.display="none";chunks.clear();init();}
</script>
</body>
</html>
