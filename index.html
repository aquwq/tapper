<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Pixel Rogue ‚Äî Fixed Visuals (32x32)</title>
<style>
  :root{--bg:#05121a;--panel:#0b1220;--accent:#ffd166}
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,monospace;color:#e6eef8}
  canvas{display:block; image-rendering:pixelated}
  #ui{position:fixed;left:50%;top:8px;transform:translateX(-50%);background:rgba(2,6,23,0.66);padding:8px 12px;border-radius:10px;z-index:60;display:flex;gap:10px;align-items:center}
  .stat{font-size:13px}
  #minimap{position:fixed;right:12px;bottom:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);z-index:55;background:#071018}
  .panel{position:fixed;right:12px;top:64px;background:var(--panel);padding:8px;border-radius:8px;z-index:55}
  button{background:#1f2937;border:1px solid rgba(255,255,255,0.04);color:#e6eef8;padding:6px 8px;border-radius:6px;cursor:pointer}
  .modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:var(--panel);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);z-index:80;display:none}
  #errorOverlay{position:fixed;left:8px;right:8px;bottom:8px;background:#7f1d1d;color:#fff;padding:10px;border-radius:8px;display:none;z-index:999}
</style>
</head>
<body>

<canvas id="game"></canvas>
<canvas id="minimap" width="180" height="180"></canvas>

<div id="ui">
  <div class="stat">‚ù§Ô∏è <span id="hp">0</span></div>
  <div class="stat">‚öî <span id="atk">0</span></div>
  <div class="stat">‚≠ê <span id="lvl">0</span></div>
  <div class="stat">üí∞ <span id="gold">0</span></div>
  <button id="btnReset">New Run</button>
</div>

<div class="panel">Wave: <span id="wave">1</span></div>

<div id="gameover" class="modal">
  <h3>–¢—ã –ø–æ–≥–∏–±</h3>
  <div id="gstats"></div>
  <div style="text-align:right;margin-top:8px"><button id="restartBtn">Restart</button></div>
</div>

<div id="errorOverlay"></div>

<script>
/* ====== Robust single-file 32x32 visual fix ======
   - Ensures canvas/resizing initialized
   - Ensures chunk preloading and fade-in
   - Spawns visible initial mobs and draws player
   - No ambiguous function/variable names
   - If any runtime error occurs it reports to #errorOverlay
================================================================= */

(() => {
  // Safe wrapper to show errors to user
  function showError(msg){
    const el = document.getElementById('errorOverlay');
    el.style.display = 'block';
    el.textContent = '–û—à–∏–±–∫–∞: ' + msg;
    console.error(msg);
  }

  try {
    // CONFIG
    const CONFIG = {
      TILE: 32,
      DPR: Math.max(1, Math.floor(window.devicePixelRatio || 1)),
      CHUNK: 512,
      PRELOAD_RADIUS: 3,
      WAVE_INTERVAL: 20000,
      INITIAL_MONSTERS: 6,
      MAX_MONSTERS: 120,
      MAX_COINS: 240,
      MAX_PARTICLES: 400,
      CHUNK_FADE_MS: 600,
      SAVE_KEY: 'pixel_32_fixed_v2'
    };

    // Canvas setup
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const mini = document.getElementById('minimap');
    const mctx = mini.getContext('2d');

    function resize(){
      const cssW = Math.max(800, window.innerWidth);
      const cssH = Math.max(600, window.innerHeight);
      canvas.width = Math.round(cssW * CONFIG.DPR);
      canvas.height = Math.round(cssH * CONFIG.DPR);
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.setTransform(CONFIG.DPR,0,0,CONFIG.DPR,0,0);

      // minimap internal resolution
      const style = getComputedStyle(mini);
      const mw = parseInt(style.width) || 180;
      const mh = parseInt(style.height) || 180;
      mini.width = mw * CONFIG.DPR;
      mini.height = mh * CONFIG.DPR;
      mctx.setTransform(CONFIG.DPR,0,0,CONFIG.DPR,0,0);
    }
    window.addEventListener('resize', resize);
    resize();

    // UI refs
    const UI = {
      hp: document.getElementById('hp'),
      atk: document.getElementById('atk'),
      lvl: document.getElementById('lvl'),
      gold: document.getElementById('gold'),
      wave: document.getElementById('wave'),
      gameover: document.getElementById('gameover'),
      gstats: document.getElementById('gstats')
    };

    // helpers
    const now = () => performance.now();
    const rand = (a,b) => Math.random()*(b-a)+a;
    const lerp = (a,b,t) => a + (b-a)*t;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    // Biomes
    function hash(x,y){ return Math.abs(Math.sin(x*127.1 + y*311.7) * 43758.5453) % 1; }
    function smoothNoise(x,y){
      const xi=Math.floor(x), yi=Math.floor(y);
      const xf=x-xi, yf=y-yi;
      const v00=hash(xi,yi), v10=hash(xi+1,yi), v01=hash(xi,yi+1), v11=hash(xi+1,yi+1);
      const u=xf*xf*(3-2*xf), v=yf*yf*(3-2*yf);
      return ( (v00*(1-u)+v10*u)*(1-v) + (v01*(1-u)+v11*u)*v );
    }
    function biomeAt(x,y){
      const n = smoothNoise(x*0.0015, y*0.0015);
      if(n < 0.33) return 0;
      if(n < 0.66) return 1;
      return 2;
    }
    const BIOMES = [
      {id:0, name:'–õ—É–≥', color:'#9AE6B4', types:['slime','slime_big']},
      {id:1, name:'–õ–µ—Å', color:'#5EEAD4', types:['wolf','wolf_fast']},
      {id:2, name:'–ü—Ä–æ–∫–ª—è—Ç—ã–π', color:'#FCA5A5', types:['imp','demon','fiend']}
    ];

    // State
    const state = {
      player: { x:0, y:0, vx:0, vy:0, facing:1, hp:150, maxHp:150, atk:9, atkCd:0, atkRange:46, speed:3.0, invul:0, lvl:1, exp:0, gold:0 },
      inventory: { potions: 2 },
      monsters: [],
      coins: [],
      particles: [],
      chunks: new Map(),
      wave: 1,
      lastWaveAt: now(),
      running: true,
      difficulty: 1.0,
      startedAt: now()
    };

    // Chunk helpers
    function chunkKey(cx,cy){ return cx + ',' + cy; }
    function ensureChunk(cx,cy){
      const key = chunkKey(cx,cy);
      if(state.chunks.has(key)) return state.chunks.get(key);
      const chunk = {cx,cy,objects:[],created:now(),alpha:0,creating:true};
      state.chunks.set(key, chunk);
      setTimeout(()=> generateChunk(chunk), 12 + Math.random()*80);
      return chunk;
    }
    function generateChunk(chunk){
      if(!chunk || (!chunk.creating && chunk.objects.length)) return;
      chunk.creating = false;
      const baseX = chunk.cx * CONFIG.CHUNK, baseY = chunk.cy * CONFIG.CHUNK;
      const centerX = baseX + CONFIG.CHUNK/2, centerY = baseY + CONFIG.CHUNK/2;
      const bId = biomeAt(centerX, centerY);
      chunk.biome = bId;
      const count = 3 + Math.floor(Math.abs(hash(chunk.cx, chunk.cy)) * 6);
      for(let i=0;i<count;i++){
        const rx = baseX + Math.random()*CONFIG.CHUNK;
        const ry = baseY + Math.random()*CONFIG.CHUNK;
        const r = Math.random();
        let type;
        if(r < 0.36) type = 'tree_small';
        else if(r < 0.56) type = 'tree_tall';
        else if(r < 0.72) type = 'bush';
        else if(r < 0.86) type = 'rock';
        else if(r < 0.95) type = 'ruin';
        else type = 'pond';
        const sizeMap = {tree_small:18, tree_tall:30, bush:10, rock:14, ruin:28, pond:44};
        const size = sizeMap[type] || 14;
        chunk.objects.push({type, x: rx, y: ry, r: size, seed: Math.random()});
      }
      chunk.created = now(); chunk.alpha = 0;
    }

    // Preload nearby chunks
    function preloadChunks(){
      const pcx = Math.floor(state.player.x / CONFIG.CHUNK), pcy = Math.floor(state.player.y / CONFIG.CHUNK);
      for(let dx=-CONFIG.PRELOAD_RADIUS; dx<=CONFIG.PRELOAD_RADIUS; dx++){
        for(let dy=-CONFIG.PRELOAD_RADIUS; dy<=CONFIG.PRELOAD_RADIUS; dy++){
          ensureChunk(pcx+dx, pcy+dy);
        }
      }
    }

    // Collision check for structures (circle)
    function collidesStruct(x,y){
      const cx = Math.floor(x / CONFIG.CHUNK), cy = Math.floor(y / CONFIG.CHUNK);
      for(let dx=-1;dx<=1;dx++){
        for(let dy=-1;dy<=1;dy++){
          const ch = state.chunks.get(chunkKey(cx+dx, cy+dy));
          if(!ch) continue;
          for(const o of ch.objects){
            const d = Math.hypot(x - o.x, y - o.y);
            if(d < o.r + 10) return {hit:true, object:o, dist:d};
          }
        }
      }
      return {hit:false};
    }

    // tryMoveEntity: fractional sliding + push-out
    function tryMoveEntity(e, nx, ny){
      const col = collidesStruct(nx, ny);
      if(!col.hit){ e.x = nx; e.y = ny; return true; }
      // fractional steps
      const steps = 6;
      for(let s=steps; s>0; s--){
        const fx = e.x + (nx - e.x) * (s/steps);
        const fy = e.y + (ny - e.y) * (s/steps);
        if(!collidesStruct(fx, fy).hit){ e.x = fx; e.y = fy; return true; }
      }
      // push out a bit
      if(col.hit){
        const o = col.object;
        const d = Math.max(0.0001, col.dist);
        const overlap = (o.r + 10) - d;
        if(overlap > 0){
          const nx2 = e.x + (e.x - o.x) / d * (overlap + 1.5);
          const ny2 = e.y + (e.y - o.y) / d * (overlap + 1.5);
          if(!collidesStruct(nx2, ny2).hit){ e.x = nx2; e.y = ny2; return true; }
        }
      }
      return false;
    }

    // Safe spawn
    function findSpawn(minR=240, tries=40){
      for(let i=0;i<tries;i++){
        const a = Math.random()*Math.PI*2;
        const r = minR + Math.random()*260;
        const x = state.player.x + Math.cos(a)*r;
        const y = state.player.y + Math.sin(a)*r;
        if(!collidesStruct(x,y).hit) return {x,y};
      }
      const a = Math.random()*Math.PI*2;
      return {x: state.player.x + Math.cos(a)*350, y: state.player.y + Math.sin(a)*350};
    }

    // Monster factory
    function spawnMonster(kind, x, y, boss=false){
      const templates = {
        slime:{hp:34, speed:0.45, atk:3, size:14},
        slime_big:{hp:60, speed:0.36, atk:5, size:20},
        wolf:{hp:24, speed:1.18, atk:4, size:12},
        wolf_fast:{hp:16, speed:1.6, atk:3, size:10},
        imp:{hp:30, speed:0.95, atk:3, size:12, ranged:true},
        demon:{hp:88, speed:0.6, atk:10, size:18},
        boss:{hp:420, speed:0.5, atk:18, size:34}
      };
      const tpl = templates[kind] || templates.slime;
      const ang = Math.random()*Math.PI*2;
      const sx = (x===undefined) ? state.player.x + Math.cos(ang)*(260 + Math.random()*260) : x;
      const sy = (y===undefined) ? state.player.y + Math.sin(ang)*(260 + Math.random()*260) : y;
      const m = {
        id: Math.random().toString(36).slice(2,9),
        type: kind, x: sx, y: sy, vx:0, vy:0, kbx:0, kby:0,
        hp: Math.round(tpl.hp * state.difficulty), maxHp: Math.round(tpl.hp * state.difficulty),
        atk: Math.round(tpl.atk * state.difficulty), speed: tpl.speed, size: tpl.size,
        ranged: !!tpl.ranged, hitCd:0, flash:0, boss: !!boss, anim:{t:Math.random()*1000}
      };
      state.monsters.push(m); return m;
    }

    // Spawn initial monsters so user sees something immediately
    function spawnInitial(){
      for(let i=0;i<CONFIG.INITIAL_MONSTERS;i++){
        const p = findSpawn(160, 80);
        const b = BIOMES[biomeAt(state.player.x + rand(-1,1), state.player.y + rand(-1,1))];
        const type = b.types[Math.floor(Math.random()*b.types.length)];
        spawnMonster(type, p.x, p.y);
      }
    }

    // Controls
    const keys = {};
    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    function movePlayer(dt){
      const p = state.player;
      let ax=0, ay=0;
      if(keys['a']||keys['arrowleft']) ax -= 1;
      if(keys['d']||keys['arrowright']) ax += 1;
      if(keys['w']||keys['arrowup']) ay -= 1;
      if(keys['s']||keys['arrowdown']) ay += 1;
      const len = Math.hypot(ax,ay);
      if(len > 0.001){
        ax /= len; ay /= len;
        const tx = ax * p.speed, ty = ay * p.speed;
        p.vx = lerp(p.vx||0, tx, 0.18); p.vy = lerp(p.vy||0, ty, 0.18);
        tryMoveEntity(p, p.x + p.vx * dt/16, p.y + p.vy * dt/16);
        if(Math.abs(p.vx) > 0.12) p.facing = p.vx < 0 ? -1 : 1;
      } else {
        p.vx = lerp(p.vx||0, 0, 0.14); p.vy = lerp(p.vy||0, 0, 0.14);
        tryMoveEntity(p, p.x + p.vx * dt/16, p.y + p.vy * dt/16);
      }
    }

    // Attack
    function playerAutoAttack(){
      const p = state.player;
      if(p.atkCd > 0){ p.atkCd--; return; }
      let target = null, minD = Infinity;
      for(const m of state.monsters){
        const d = Math.hypot(m.x - p.x, m.y - p.y);
        if(d <= p.atkRange + m.size && d < minD){ minD = d; target = m; }
      }
      if(target){
        const dmg = p.atk + Math.floor(Math.random()*2);
        target.hp -= dmg;
        const dx = target.x - p.x, dy = target.y - p.y, dd = Math.max(1, Math.hypot(dx,dy));
        target.kbx = (dx/dd)*6; target.kby = (dy/dd)*6;
        target.flash = 10;
        state.particles.push({type:'num', x:target.x, y:target.y - target.size - 6, vx:rand(-0.4,0.4), vy:-1.2, text:'-' + dmg, life:700, created: now()});
        p.atkCd = Math.max(10, 18 - Math.floor(p.lvl/3));
      }
    }

    // Monster AI & update
    function updateMonsters(dt){
      const p = state.player;
      if(state.monsters.length > CONFIG.MAX_MONSTERS) state.monsters.length = CONFIG.MAX_MONSTERS;
      for(let i=state.monsters.length-1;i>=0;i--){
        const m = state.monsters[i];
        const dx = p.x - m.x, dy = p.y - m.y;
        const d = Math.hypot(dx,dy) || 1;
        let desiredVx = (dx/d) * m.speed, desiredVy = (dy/d) * m.speed;
        // avoidance
        for(const other of state.monsters){
          if(other === m) continue;
          const ddx = m.x - other.x, ddy = m.y - other.y;
          const dd = Math.hypot(ddx,ddy) || 1;
          if(dd < (m.size + other.size) * 0.9){ desiredVx += (ddx/dd)*0.45; desiredVy += (ddy/dd)*0.45; }
        }
        m.vx = lerp(m.vx||0, desiredVx, 0.12); m.vy = lerp(m.vy||0, desiredVy, 0.12);
        tryMoveEntity(m, m.x + (m.vx + (m.kbx||0)) * dt/16, m.y + (m.vy + (m.kby||0)) * dt/16);
        m.kbx *= 0.86; m.kby *= 0.86;

        // attack
        if(d < m.size + 14 && m.hitCd <= 0){
          if(p.invul <= 0){
            const hit = Math.max(1, Math.round(m.atk * 0.6));
            p.hp -= hit; p.invul = 36;
            state.particles.push({type:'num', x:p.x, y:p.y - 20, vx:rand(-0.6,0.6), vy:-1.1, text:'-' + hit, life:700, created: now()});
            p.x += (p.x - m.x)/d * 6; p.y += (p.y - m.y)/d * 6;
          }
          m.hitCd = 70 + Math.random()*20;
        }
        if(m.hitCd > 0) m.hitCd--;
        if(m.flash > 0) m.flash--;
        if(m.hp <= 0){
          const drop = 2 + Math.floor(Math.random()*3);
          for(let k=0;k<drop && state.coins.length < CONFIG.MAX_COINS;k++){
            state.coins.push({ x: m.x + rand(-8,8), y: m.y + rand(-8,8), vx: rand(-1.6,1.6), vy: rand(-3,-1), created: now(), life:6000, size:4 + Math.random()*3 });
          }
          state.player.exp = (state.player.exp || 0) + Math.round(m.maxHp/8);
          state.particles.push({type:'num', x:m.x, y:m.y-8, vx:0, vy:-0.8, text:'+XP', life:900, created:now()});
          state.monsters.splice(i,1);
          continue;
        }
        if(Math.hypot(m.x - p.x, m.y - p.y) > 3500) state.monsters.splice(i,1);
      }
    }

    // particles & coins updates
    function updateParticles(dt){
      for(let i=state.particles.length-1;i>=0;i--){
        const p = state.particles[i];
        p.x += (p.vx||0)*dt/16; p.y += (p.vy||0)*dt/16; if(p.vy !== undefined) p.vy += 0.06 * dt/16;
        if(now() - p.created > (p.life || 600)) state.particles.splice(i,1);
        if(p.type === 'proj'){
          const d = Math.hypot(p.x - state.player.x, p.y - state.player.y);
          if(d < 14 && state.player.invul <= 0){ state.player.hp -= p.dmg || 2; state.player.invul = 36; state.particles.splice(i,1); continue; }
        }
      }
      if(state.particles.length > CONFIG.MAX_PARTICLES) state.particles.splice(0, state.particles.length - CONFIG.MAX_PARTICLES);
    }
    function updateCoins(dt){
      for(let i=state.coins.length-1;i>=0;i--){
        const c = state.coins[i];
        c.vy += 0.08 * dt/16; c.x += c.vx * dt/16; c.y += c.vy * dt/16;
        const dx = state.player.x - c.x, dy = state.player.y - c.y; const d = Math.hypot(dx,dy) || 1;
        if(d < 120){ c.vx += (dx/d) * 0.25 * dt/16; c.vy += (dy/d) * 0.25 * dt/16; }
        if(d < 12){ state.player.gold += 1; state.particles.push({type:'coin', x:c.x, y:c.y, vx:0, vy:-1, life:400, created:now()}); state.coins.splice(i,1); continue; }
        if(now() - c.created > c.life) state.coins.splice(i,1);
      }
      if(state.coins.length > CONFIG.MAX_COINS) state.coins.length = CONFIG.MAX_COINS;
    }

    // waves & leveling
    function spawnWave(n){
      for(let i=0;i<n;i++){
        const p = findSpawn(220, 50);
        const bIdx = biomeAt(state.player.x + rand(-40,40), state.player.y + rand(-40,40));
        const types = BIOMES[bIdx].types;
        const type = types[Math.floor(Math.random()*types.length)];
        spawnMonster(type, p.x, p.y);
      }
    }
    function maybeSpawnWave(){
      if(now() - state.lastWaveAt >= CONFIG.WAVE_INTERVAL){
        state.wave++; state.lastWaveAt = now();
        const c = Math.min(60, 4 + state.wave + Math.floor(state.wave*0.5));
        spawnWave(c);
        if(state.wave % 7 === 0){ const p = findSpawn(320,80); spawnMonster('boss', p.x, p.y, true); }
        state.player.gold += Math.round(state.wave * 0.7);
      }
    }
    function updateLeveling(){
      const need = state.player.lvl * 50;
      if((state.player.exp||0) >= need){
        state.player.exp -= need; state.player.lvl++; state.player.maxHp += 10; state.player.hp = Math.min(state.player.maxHp, state.player.hp + 12);
        if(state.player.lvl % 5 === 0) state.difficulty *= 1.12;
        // show simple banner
        document.getElementById('wave').textContent = state.wave;
        const gm = document.getElementById('gstats');
        // small visual feedback via console and temporary DOM banner could be added
      }
    }

    // Draw world (tile-based 32)
    function drawWorld(){
      const camX = state.player.x, camY = state.player.y;
      const tile = CONFIG.TILE;
      const cols = Math.ceil((canvas.width/CONFIG.DPR)/tile) + 4;
      const rows = Math.ceil((canvas.height/CONFIG.DPR)/tile) + 4;
      const startX = Math.floor((camX - (canvas.width/CONFIG.DPR)/2) / tile) - 1;
      const startY = Math.floor((camY - (canvas.height/CONFIG.DPR)/2) / tile) - 1;
      for(let y=0;y<rows;y++){
        for(let x=0;x<cols;x++){
          const wx = (startX + x) * tile + tile/2;
          const wy = (startY + y) * tile + tile/2;
          const bi = BIOMES[biomeAt(wx,wy)];
          ctx.fillStyle = bi.color;
          const sx = Math.round((x * tile) - ((camX - (canvas.width/CONFIG.DPR)/2) % tile));
          const sy = Math.round((y * tile) - ((camY - (canvas.height/CONFIG.DPR)/2) % tile));
          ctx.fillRect(sx, sy, tile+1, tile+1);
          if((x+y)%3===0){ ctx.fillStyle = 'rgba(0,0,0,0.02)'; ctx.fillRect(sx+4, sy+4, 6,6); }
        }
      }

      // draw chunk objects
      const pcx = Math.floor(camX / CONFIG.CHUNK), pcy = Math.floor(camY / CONFIG.CHUNK);
      for(let dx=-CONFIG.PRELOAD_RADIUS-1; dx<=CONFIG.PRELOAD_RADIUS+1; dx++){
        for(let dy=-CONFIG.PRELOAD_RADIUS-1; dy<=CONFIG.PRELOAD_RADIUS+1; dy++){
          const ch = ensureChunk(pcx+dx, pcy+dy);
          if(!ch) continue;
          const age = Math.max(0, now() - (ch.created || now()));
          ch.alpha = Math.min(1, age / CONFIG.CHUNK_FADE_MS);
          for(const o of ch.objects){
            const sx = Math.round((canvas.width/CONFIG.DPR)/2 + (o.x - camX));
            const sy = Math.round((canvas.height/CONFIG.DPR)/2 + (o.y - camY));
            if(sx < -160 || sx > canvas.width/CONFIG.DPR + 160 || sy < -160 || sy > canvas.height/CONFIG.DPR + 160) continue;
            ctx.globalAlpha = ch.alpha;
            if(ch.alpha < 0.5){ ctx.fillStyle='rgba(0,0,0,0.08)'; ctx.fillRect(sx-6,sy-6,12,12); }
            else {
              if(o.type==='tree_small'){ ctx.fillStyle='#7c4a1f'; ctx.fillRect(sx-3, sy-10, 6, 10); ctx.fillStyle='#14532d'; ctx.fillRect(sx-10, sy-20, 20, 14); }
              else if(o.type==='tree_tall'){ ctx.fillStyle='#5b3a16'; ctx.fillRect(sx-4, sy-18, 8, 18); ctx.fillStyle='#064e3b'; ctx.fillRect(sx-18, sy-36, 36, 26); }
              else if(o.type==='bush'){ ctx.fillStyle='#14532d'; ctx.fillRect(sx-10, sy-6, 20, 12); ctx.fillStyle='#0b3a25'; ctx.fillRect(sx-4, sy-2, 8, 4); }
              else if(o.type==='rock'){ ctx.fillStyle='#6b7280'; ctx.fillRect(sx - Math.floor(o.r/2), sy - Math.floor(o.r/2), o.r, o.r); }
              else if(o.type==='ruin'){ ctx.fillStyle='#44403c'; ctx.fillRect(sx - o.r/1.6, sy - o.r/2, o.r*1.6, o.r/1.2); ctx.fillStyle='#2b2b2b'; ctx.fillRect(sx - 6, sy - o.r/4, 12, o.r/6); }
              else if(o.type==='pond'){ ctx.fillStyle='#38bdf8'; ctx.beginPath(); ctx.ellipse(sx,sy,o.r,o.r*0.6,0,0,Math.PI*2); ctx.fill(); }
            }
            ctx.globalAlpha = 1;
          }
        }
      }
    }

    // Draw player
    function drawPlayer(){
      const cx = canvas.width/(2*CONFIG.DPR), cy = canvas.height/(2*CONFIG.DPR);
      const p = state.player;
      const bob = Math.sin(now()/180) * 1.6;
      ctx.fillStyle = 'rgba(0,0,0,0.36)'; ctx.beginPath(); ctx.ellipse(cx, cy+18, 18, 8, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#0f1724'; ctx.fillRect(cx-9, cy+6+bob, 5, 10); ctx.fillRect(cx+4, cy+6+bob, 5, 10);
      ctx.fillStyle = '#1e40af'; ctx.fillRect(cx-10, cy-6+bob, 20, 18);
      ctx.fillStyle = '#fce8c4'; ctx.beginPath(); ctx.ellipse(cx, cy-12+bob, 7.6, 7.6, 0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#081018';
      if(p.facing < 0){ ctx.fillRect(cx-5, cy-14+bob, 2,2); ctx.fillRect(cx-2, cy-14+bob, 2,2); }
      else { ctx.fillRect(cx+2, cy-14+bob, 2,2); ctx.fillRect(cx+5, cy-14+bob, 2,2); }
      // sword
      ctx.save(); ctx.translate(cx, cy+bob);
      const swing = Math.max(0, (p.atkCd||0) - 6) / 12;
      if(p.facing > 0){ ctx.fillStyle='#c7c7c7'; ctx.fillRect(12 + swing*6, -3, 30 - swing*10, 6); ctx.fillStyle='#6b7280'; ctx.fillRect(40 - swing*8, -2, 4,4); }
      else { ctx.fillStyle='#c7c7c7'; ctx.fillRect(-42 - swing*6, -3, 30 - swing*10, 6); ctx.fillStyle='#6b7280'; ctx.fillRect(-44 + swing*8, -2, 4,4); }
      ctx.restore();
    }

    // Draw monsters/coins/particles/minimap
    function drawMonsters(){
      const cx = canvas.width/(2*CONFIG.DPR), cy = canvas.height/(2*CONFIG.DPR);
      ctx.font = '11px monospace';
      for(const m of state.monsters){
        const sx = cx + (m.x - state.player.x), sy = cy + (m.y - state.player.y);
        if(sx < -200 || sx > canvas.width/CONFIG.DPR + 200) continue;
        const bob = Math.sin((now() + (m.anim?.t||0))/200)*2;
        ctx.fillStyle = 'rgba(0,0,0,0.26)'; ctx.beginPath(); ctx.ellipse(sx, sy+10, m.size*0.7, m.size*0.35, 0,0,Math.PI*2); ctx.fill();
        if(m.type.startsWith('slime')){ ctx.fillStyle = m.flash ? '#fff' : '#12b76a'; ctx.beginPath(); ctx.ellipse(sx, sy + bob, m.size, m.size*0.88,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#04121a'; ctx.fillRect(sx-4, sy-2+bob, 2,2); ctx.fillRect(sx+2, sy-2+bob, 2,2); }
        else if(m.type.startsWith('wolf')){ ctx.fillStyle = m.flash ? '#fff' : '#7c3aed'; ctx.fillRect(sx - m.size, sy - m.size + bob, m.size*2, m.size*2); }
        else if(m.type==='imp'){ ctx.fillStyle = m.flash ? '#fff' : '#f97316'; ctx.beginPath(); ctx.moveTo(sx,sy-m.size+bob); ctx.lineTo(sx+m.size,sy+m.size+bob); ctx.lineTo(sx-m.size,sy+m.size+bob); ctx.closePath(); ctx.fill(); }
        else { ctx.fillStyle = m.flash ? '#fff' : '#ef4444'; ctx.beginPath(); ctx.ellipse(sx, sy + bob, m.size*1.05, m.size*0.95,0,0,Math.PI*2); ctx.fill(); }
        // hp bar
        ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(sx - m.size, sy - m.size - 12, m.size*2, 6);
        ctx.fillStyle = '#10b981'; ctx.fillRect(sx - m.size + 1, sy - m.size - 11, Math.max(0, (m.hp / m.maxHp) * (m.size*2 - 2)), 4);
        ctx.fillStyle = '#fff'; ctx.fillText(Math.max(0, Math.floor(m.hp)), sx - 8, sy - m.size - 16);
      }
    }
    function drawCoins(){
      const cx = canvas.width/(2*CONFIG.DPR), cy = canvas.height/(2*CONFIG.DPR);
      for(const c of state.coins){
        const sx = cx + (c.x - state.player.x), sy = cy + (c.y - state.player.y);
        if(sx < -160 || sx > canvas.width/CONFIG.DPR + 160) continue;
        ctx.fillStyle = '#facc15'; ctx.beginPath(); ctx.arc(sx, sy, c.size, 0, Math.PI*2); ctx.fill();
      }
    }
    function drawParticles(){
      const cx = canvas.width/(2*CONFIG.DPR), cy = canvas.height/(2*CONFIG.DPR);
      ctx.textAlign = 'center';
      for(const p of state.particles){
        const sx = cx + (p.x - state.player.x), sy = cy + (p.y - state.player.y);
        if(p.type === 'hit'){ ctx.fillStyle='rgba(255,200,100,0.9)'; ctx.fillRect(sx,sy,2,2); }
        if(p.type === 'coin'){ ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillRect(sx,sy-6,2,2); }
        if(p.type === 'proj'){ ctx.fillStyle='#f97316'; ctx.fillRect(sx-2,sy-2,4,4); }
        if(p.type === 'num' && p.text){ ctx.fillStyle = '#fff'; ctx.font = '12px monospace'; ctx.fillText(p.text, sx, sy); }
      }
    }
    function drawMinimap(){
      const mw = mini.width / CONFIG.DPR, mh = mini.height / CONFIG.DPR;
      mctx.clearRect(0,0,mw,mh);
      const px = state.player.x, py = state.player.y;
      for(let y=0;y<mh;y++){
        for(let x=0;x<mw;x++){
          const wx = px + (x - mw/2) * 20;
          const wy = py + (y - mh/2) * 20;
          const b = BIOMES[biomeAt(wx,wy)];
          mctx.fillStyle = b.color; mctx.fillRect(x,y,1,1);
        }
      }
      // draw monsters small
      for(const m of state.monsters){
        const rx = Math.round(mw/2 + (m.x - px)/20), ry = Math.round(mh/2 + (m.y - py)/20);
        if(rx>=0 && rx<mw && ry>=0 && ry<mh) { mctx.fillStyle = m.boss ? '#ff0' : '#fff'; mctx.fillRect(rx,ry,2,2); }
      }
      mctx.fillStyle = '#2563eb'; mctx.fillRect(Math.floor(mw/2)-1, Math.floor(mh/2)-1, 3, 3);
    }

    // Main loop
    let last = now();
    function mainLoop(ts){
      const dt = Math.min(40, ts - last); last = ts;
      if(state.running){
        preloadChunks();
        movePlayer(dt);
        playerAutoAttack();
        updateMonsters(dt);
        updateParticles(dt);
        updateCoins(dt);
        maybeSpawnWave();
        updateLeveling();
        if(state.player.hp <= 0){
          state.running = false;
          UI.gstats.textContent = `Level: ${state.player.lvl}  Wave: ${state.wave}  Gold: ${state.player.gold}`;
          UI.gameover.style.display = 'block';
        }
      }
      // draw
      ctx.clearRect(0,0, canvas.width/CONFIG.DPR, canvas.height/CONFIG.DPR);
      drawWorld();
      drawMonsters();
      drawPlayer();
      drawCoins();
      drawParticles();
      drawMinimap();
      // UI
      document.getElementById('hp').textContent = Math.max(0, Math.floor(state.player.hp)) + '/' + state.player.maxHp;
      document.getElementById('atk').textContent = state.player.atk;
      document.getElementById('lvl').textContent = state.player.lvl;
      document.getElementById('gold').textContent = state.player.gold;
      document.getElementById('wave').textContent = state.wave;
      requestAnimationFrame(mainLoop);
    }

    // simple periodic functions
    setInterval(()=> maybeSpawnWave(), 1000);
    setInterval(()=> updateLeveling(), 1000);

    // Start/Init
    spawnInitial();
    requestAnimationFrame(mainLoop);

    // UI handlers
    document.getElementById('btnReset').addEventListener('click', () => {
      // simple restart
      state.player = { x:0,y:0,vx:0,vy:0,facing:1,hp:150,maxHp:150,atk:9,atkCd:0,atkRange:46,speed:3.0,invul:0,lvl:1,exp:0,gold:0 };
      state.inventory = {potions:2}; state.monsters = []; state.coins=[]; state.particles=[]; state.chunks.clear();
      state.wave = 1; state.lastWaveAt = now(); state.running = true; state.difficulty = 1.0; state.startedAt = now();
      spawnInitial();
      UI.gameover.style.display = 'none';
    });
    document.getElementById('restartBtn').addEventListener('click', () => document.getElementById('btnReset').click());

    // Save/load minimal state
    function saveGame(){ try{ const s = {player:state.player, inventory:state.inventory, wave:state.wave, difficulty:state.difficulty, startedAt:state.startedAt}; localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(s)); }catch(e){} }
    function loadGame(){ try{ const s = JSON.parse(localStorage.getItem(CONFIG.SAVE_KEY)); if(s){ state.player = Object.assign(state.player, s.player); state.inventory = s.inventory || state.inventory; state.wave = s.wave || state.wave; state.difficulty = s.difficulty || state.difficulty; state.startedAt = s.startedAt || state.startedAt; } }catch(e){} }
    loadGame(); setInterval(saveGame, 5000);

    // expose for debugging
    window._state = state;
    window._spawnMonster = spawnMonster;
    window._ensureChunk = ensureChunk;

  } catch (err){
    // show error overlay
    const overlay = document.getElementById('errorOverlay');
    overlay.style.display = 'block';
    overlay.textContent = 'Fatal error: ' + (err && err.message ? err.message : String(err));
    console.error(err);
  }
})();
</script>
</body>
</html>
